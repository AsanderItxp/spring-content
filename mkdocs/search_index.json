{
    "docs": [
        {
            "location": "/", 
            "text": "Spring Content\n\n\nCloud-Native Headless Content Services for Spring.\n\n\nFor creating services that manage content such as documents, images and digital assets such as video.  \n\n\nBuild your own cloud-native, scale-out headless content services using the exact same components as the Enterprise Content Management (ECM) vendors such as Documentum and OpenText, without the hassle.   \n\n\nFeatures\n\n\n\n\n\n\nStandardized content access no matter where it is stored  \n\n\n\n\n\n\nContent/metadata association   \n\n\n\n\n\n\nContent Search\n\n\n\n\n\n\nContent Transformation\n\n\n\n\n\n\nVideos\n\n\n\n\n\n\nAn Overview of Spring Content\n\n\n\n\n\n\nSpringOne 2016 - Persistence Arrives on Cloud Foundry\n\n\n\n\n\n\nSpringOne 2017 - A Guided Tour From Code Base To Platform 11:28 - 21:58\n \n\n\n\n\n\n\nSpringOne 2018 - From Content Management to Content Services with Spring Boot, Data and Content\n\n\n\n\n\n\nModules\n\n\n\n\n\n\nSpring Content Commons - Core Spring concepts underpinning every Spring Content project.\n\n\n\n\n\n\nSpring Content S3 - Store support for Amazon S3 objects.  Also supports DellEMC ECS\n\n\n\n\n\n\nSpring Content Filesystem - Store support for the Filesystem files\n\n\n\n\n\n\nSpring Content Mongo - Store support for Mongo's GridFS\n\n\n\n\n\n\nSpring Content JPA - Store support for JPA BLOBs\n\n\n\n\n\n\nSpring Content Renditions - Extensible rendition service for content transformations\n\n\n\n\n\n\nSpring Content Solr - Content indexing and search with Apache Solr\n\n\n\n\n\n\nSpring Data REST - Exports Spring Content stores as hypermedia-driven RESTful resources.\n\n\n\n\n\n\nComing Soon\n\n\n\n\n\n\nSpring Content ElasticSearch - Content indexing and search with Amazon Elastic Search\n\n\n\n\n\n\nSpring Content CMIS - CMIS-compliant entity model and REST API\n\n\n\n\n\n\nOverview\n\n\n\n\nFigure 1. understanding how Spring Content fits into the Spring eco-system\n\n\nQuick Start\n\n\ndependency\n\n    \ngroupId\ncom.github.paulcwarren\n/groupId\n\n    \nartifactId\nspring-content-fs-boot-starter\n/artifactId\n\n    \nversion\n0.5.0\n/version\n\n\n/dependency\n\n\n\n\n\nFor a quick taste, look at the following domain object:\n\n\n@Entity\npublic class SopDocument {\n\n    private @Id @GeneratedValue Long id;\n    private String title;\n    private String[] authors, keywords;\n\n    // Spring Content managed attribute\n    private @ContentId String contentId;\n\n    private SopDocument() {}\n    public SopDocument(String title, String[] authors, String[] keywords)   {\n        this.title = title;\n        this.authors = authors;\n        this.keywords = keywords;\n    }\n}\n\n\n\n\nThis defines a simple JPA entity with a few structured data fields; title, authors and keywords and one Spring Content-managed data field; \n@ContentId\n.  \n\n\nThe structured data fields are handled in the usual way through a \nCrudRepository\nSopDocument,String\n interface.  \n\n\nContent is handled separately with a ContentStore interface:-\n\n\npublic interface SopDocumentContent extends ContentStore\nSopDocument, String\n {\n}\n\n\n\n\nThis interface extends Spring Content\u2019s \nContentStore\n, defines the type (SopDocument) and the id type (String).  Put this code inside a Spring Boot application with \nspring-boot-starter-data-jpa\n and \nspring-content-fs-boot-starter\n like this:\n\n\n@SpringBootApplication\npublic class MyApp {\n\n    public static void main(String[] args) {\n        SpringApplication.run(MyApp.class, args);\n    }\n}\n\n\n\n\nLaunch your app and Spring Content (having been autoconfigured by Boot) will automatically craft a concrete set of operations for handling content associated with this Entity:\n\n\n\n\n\n\nsetContent(S property, InputStream content)\n\n\n\n\n\n\nInputStream getContent(S property)\n\n\n\n\n\n\nunsetContent(S property)\n\n\n\n\n\n\nTo see more following out first \nGetting Started Guide\n, or watch our \nSpringOne 2016 talk\n.\n\n\nReference Documentation\n\n\n\n\n\n\n\n\nModule\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSpring Content S3\n\n\nCurrent\n\n\nLastest Release\n\n\n\n\n\n\nSpring Content Filesystem\n\n\nCurrent\n\n\nLastest Release\n\n\n\n\n\n\nSpring Content Mongo\n\n\nCurrent\n\n\nLastest Release\n\n\n\n\n\n\nSpring Content JPA\n\n\nCurrent\n\n\nLastest Release\n\n\n\n\n\n\nSpring Content REST\n\n\nCurrent\n\n\nLastest Release", 
            "title": "Home"
        }, 
        {
            "location": "/#spring-content", 
            "text": "Cloud-Native Headless Content Services for Spring.  For creating services that manage content such as documents, images and digital assets such as video.    Build your own cloud-native, scale-out headless content services using the exact same components as the Enterprise Content Management (ECM) vendors such as Documentum and OpenText, without the hassle.", 
            "title": "Spring Content"
        }, 
        {
            "location": "/#features", 
            "text": "Standardized content access no matter where it is stored      Content/metadata association       Content Search    Content Transformation", 
            "title": "Features"
        }, 
        {
            "location": "/#videos", 
            "text": "An Overview of Spring Content    SpringOne 2016 - Persistence Arrives on Cloud Foundry    SpringOne 2017 - A Guided Tour From Code Base To Platform 11:28 - 21:58      SpringOne 2018 - From Content Management to Content Services with Spring Boot, Data and Content", 
            "title": "Videos"
        }, 
        {
            "location": "/#modules", 
            "text": "Spring Content Commons - Core Spring concepts underpinning every Spring Content project.    Spring Content S3 - Store support for Amazon S3 objects.  Also supports DellEMC ECS    Spring Content Filesystem - Store support for the Filesystem files    Spring Content Mongo - Store support for Mongo's GridFS    Spring Content JPA - Store support for JPA BLOBs    Spring Content Renditions - Extensible rendition service for content transformations    Spring Content Solr - Content indexing and search with Apache Solr    Spring Data REST - Exports Spring Content stores as hypermedia-driven RESTful resources.", 
            "title": "Modules"
        }, 
        {
            "location": "/#coming-soon", 
            "text": "Spring Content ElasticSearch - Content indexing and search with Amazon Elastic Search    Spring Content CMIS - CMIS-compliant entity model and REST API", 
            "title": "Coming Soon"
        }, 
        {
            "location": "/#overview", 
            "text": "Figure 1. understanding how Spring Content fits into the Spring eco-system", 
            "title": "Overview"
        }, 
        {
            "location": "/#quick-start", 
            "text": "dependency \n     groupId com.github.paulcwarren /groupId \n     artifactId spring-content-fs-boot-starter /artifactId \n     version 0.5.0 /version  /dependency   For a quick taste, look at the following domain object:  @Entity\npublic class SopDocument {\n\n    private @Id @GeneratedValue Long id;\n    private String title;\n    private String[] authors, keywords;\n\n    // Spring Content managed attribute\n    private @ContentId String contentId;\n\n    private SopDocument() {}\n    public SopDocument(String title, String[] authors, String[] keywords)   {\n        this.title = title;\n        this.authors = authors;\n        this.keywords = keywords;\n    }\n}  This defines a simple JPA entity with a few structured data fields; title, authors and keywords and one Spring Content-managed data field;  @ContentId .    The structured data fields are handled in the usual way through a  CrudRepository SopDocument,String  interface.    Content is handled separately with a ContentStore interface:-  public interface SopDocumentContent extends ContentStore SopDocument, String  {\n}  This interface extends Spring Content\u2019s  ContentStore , defines the type (SopDocument) and the id type (String).  Put this code inside a Spring Boot application with  spring-boot-starter-data-jpa  and  spring-content-fs-boot-starter  like this:  @SpringBootApplication\npublic class MyApp {\n\n    public static void main(String[] args) {\n        SpringApplication.run(MyApp.class, args);\n    }\n}  Launch your app and Spring Content (having been autoconfigured by Boot) will automatically craft a concrete set of operations for handling content associated with this Entity:    setContent(S property, InputStream content)    InputStream getContent(S property)    unsetContent(S property)    To see more following out first  Getting Started Guide , or watch our  SpringOne 2016 talk .", 
            "title": "Quick Start"
        }, 
        {
            "location": "/#reference-documentation", 
            "text": "Module        Spring Content S3  Current  Lastest Release    Spring Content Filesystem  Current  Lastest Release    Spring Content Mongo  Current  Lastest Release    Spring Content JPA  Current  Lastest Release    Spring Content REST  Current  Lastest Release", 
            "title": "Reference Documentation"
        }, 
        {
            "location": "/spring-content-fs-docs/", 
            "text": "Getting Started with Spring Content\n\n\nWhat you'll build\n\n\nYou'll build an application that uses Spring Content to build a simple web-based document list.\n\n\nWhat you'll need\n\n\n\n\n\n\nAbout 30 minutes\n\n\n\n\n\n\nA favorite text editor or IDE\n\n\n\n\n\n\nJDK 1.8 or later\n\n\n\n\n\n\nMaven 3.0+\n\n\n\n\n\n\nYou can also import the code from this guide as well as view the web page directly into Spring Tool Suite (STS) and work your way through it from there.\n\n\nHow to complete this guide\n\n\nLike most Spring Getting Started guides, you can start form scratch and complete each step, or you can bypass basic setup steps that are already familiar to you.  Either way, you end up with working code.\n\n\nTo start from scratch, move on to Build with Maven.\n\n\nTo skip the basics, do the following:\n\n\n\n\n\n\nDownload and unzip the source repository for this guide, or clone it using Git: \ngit clone https://github.com/paulcwarren/spring-content-gettingstarted.git\n\n\n\n\n\n\ncd\n into \nspring-content-gettingstarted/spring-content-fs/initial\n\n\n\n\n\n\nJump ahead to \nDefine a simple entity\n.\nWhen you\u2019re finished, you can check your results against the code in \nspring-content-gettingstarted/spring-content-fs/complete\n.\n\n\n\n\n\n\nBuild with Maven\n\n\nFirst you set up a basic build script. You can use any build system you like when building apps with Spring, but the code you need to work with \nMaven\n is included here.  If you\u2019re not familiar with Maven, refer to \nBuilding Java Projects with Maven\n.\n\n\nCreate a directory structure\n\n\nIn a project directory of your choosing, create the following subdirectory structure; for example, with \nmkdir -p src/main/java/gettingstarted\n on *nix systems:\n\n\n\u221f src\n   \u221f main\n       \u221f java\n           \u221f gettingstarted\n       \u221f resources\n           \u221f static\n\n\n\n\npom.xml\n\n\n?xml version=\n1.0\n encoding=\nUTF-8\n?\n\n\nproject xmlns=\nhttp://maven.apache.org/POM/4.0.0\n xmlns:xsi=\nhttp://www.w3.org/2001/XMLSchema-instance\n\n    xsi:schemaLocation=\nhttp://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\n\n    \nmodelVersion\n4.0.0\n/modelVersion\n\n\n    \ngroupId\ncom.github.paulcwarren\n/groupId\n\n    \nartifactId\ngettingstarted-spring-content-fs\n/artifactId\n\n    \nversion\n0.0.1\n/version\n\n    \npackaging\njar\n/packaging\n\n\n    \nparent\n\n        \ngroupId\norg.springframework.boot\n/groupId\n\n        \nartifactId\nspring-boot-starter-parent\n/artifactId\n\n        \nversion\n2.0.6.RELEASE\n/version\n\n    \n/parent\n\n\n    \nproperties\n\n        \nproject.build.sourceEncoding\nUTF-8\n/project.build.sourceEncoding\n\n        \njava.version\n1.8\n/java.version\n\n    \n/properties\n\n\n    \ndependencies\n\n        \ndependency\n\n            \ngroupId\norg.springframework.boot\n/groupId\n\n            \nartifactId\nspring-boot-starter-web\n/artifactId\n\n        \n/dependency\n\n        \ndependency\n\n            \ngroupId\norg.springframework.boot\n/groupId\n\n            \nartifactId\nspring-boot-starter-data-jpa\n/artifactId\n\n        \n/dependency\n\n        \ndependency\n\n            \ngroupId\ncom.h2database\n/groupId\n\n            \nartifactId\nh2\n/artifactId\n\n        \n/dependency\n\n        \ndependency\n\n            \ngroupId\norg.springframework.boot\n/groupId\n\n            \nartifactId\nspring-boot-starter-data-rest\n/artifactId\n\n        \n/dependency\n\n        \ndependency\n\n            \ngroupId\ncom.github.paulcwarren\n/groupId\n\n            \nartifactId\nspring-content-fs-boot-starter\n/artifactId\n\n            \nversion\n0.5.0\n/version\n\n        \n/dependency\n\n    \n/dependencies\n\n\n    \nbuild\n\n        \nplugins\n\n            \nplugin\n\n                \ngroupId\norg.springframework.boot\n/groupId\n\n                \nartifactId\nspring-boot-maven-plugin\n/artifactId\n\n            \n/plugin\n\n        \n/plugins\n\n    \n/build\n\n\n/project\n\n\n\n\n\nWe add several dependencies:-\n\n\n\n\n\n\nSpring Boot Starter Web provides the web server framework\n\n\n\n\n\n\nSpring Boot Starter Data JPA will provide a relational database to\nstore the metadata of our files.  In this case we are using the H2\nin-memory database\n\n\n\n\n\n\nSpring Boot Starter Data REST will provide REST endpoints for our File\nmetadata\n\n\n\n\n\n\nSpring Boot Starter Content FS will provide a Filesystem-based\nstore for the content of each file and manage the\nassociation with an Entity\n\n\n\n\n\n\nDefine a simple Entity\n\n\nLet's define a simple Entity to represent a File.\n\n\nsrc/main/java/gettingstarted/File.java\n\n\npackage gettingstarted;\n\nimport java.util.Date;\n\nimport javax.persistence.Entity;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.GenerationType;\nimport javax.persistence.Id;\n\nimport org.springframework.content.commons.annotations.ContentId;\nimport org.springframework.content.commons.annotations.ContentLength;\n\n@Entity\npublic class File {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long id;\n    private String name;\n    private Date created = new Date();\n    private String summary;\n\n    @ContentId private String contentId;\n    @ContentLength private long contentLength;\n    private String mimeType = \ntext/plain\n;\n\n    public Long getId() {\n        return id;\n    }\n\n    public void setId(Long id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Date getCreated() {\n        return created;\n    }\n\n    public void setCreated(Date created) {\n        this.created = created;\n    }\n\n    public String getSummary() {\n        return summary;\n    }\n\n    public void setSummary(String summary) {\n        this.summary = summary;\n    }\n\n    public String getContentId() {\n        return contentId;\n    }\n\n    public void setContentId(String contentId) {\n        this.contentId = contentId;\n    }\n\n    public long getContentLength() {\n        return contentLength;\n    }\n\n    public void setContentLength(long contentLength) {\n        this.contentLength = contentLength;\n    }\n\n    public String getMimeType() {\n        return mimeType;\n    }\n\n    public void setMimeType(String mimeType) {\n        this.mimeType = mimeType;\n    }\n}\n\n\n\n\nAs you would expect we created a standard JPA Entity to capture some metadata about our file; \nname\n and \nsummary\n.  In addition, because we will be serving these files over the web, we also record \nmimeType\n so that we can instruct the browser correctly.\n\n\nWe then add two annotated Spring Content fields; \n@ContentId\n and \n@ContentLength\n.  \n@ContentId\n allows us to associate a stream of binary data with an Entity and \n@ContentLength\n records the length of that stream.  These will be automatically managed by Spring Content.\n\n\nCreate a File Repository\n\n\nNext, as you would also expect, we create a \nCrudRepository\n for handling File entities and we export it as a \n@RepositoryRestResource\n so, for the cost of writing just one interface and annotating it, we get the ability to create, read, update and delete File entities using REST endpoints.\n\n\n\n\nNB. For more information on Spring Data JPA and Spring Data REST see their respective spring.io getting started guides.\n\n\n\n\nsrc/main/java/gettingstated/FileRepository.java\n\n\npackage gettingstarted;\n\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.rest.core.annotation.RepositoryRestResource;\n\n@RepositoryRestResource(path=\nfiles\n, collectionResourceRel=\nfiles\n)\npublic interface FileRepository extends JpaRepository\nFile, Long\n {\n}\n\n\n\n\nCreate a File Content Store\n\n\nSimilarly, we then create a \nContentStore\n for handling content associated with the File entity.\n\n\nsrc/main/java/gettngstarted/FileContentStore.java\n\n\npackage gettingstarted;\n\nimport org.springframework.content.commons.repository.ContentStore;\n\npublic interface FileContentStore extends ContentStore\nFile, String\n {\n}\n\n\n\n\nLet's investigate this interface:-\n\n\n\n\n\n\nContentStore\n provides several methods for handling content; setContent,\ngetContent and unsetContent\n\n\n\n\n\n\nThe dependency \ncom.github.paulcwarren:spring-content-fs-boot-starter\n\nprovides a Filesystem-based implementation of this interface and Spring\nContent auto-configuration ensures that this implementation will be used\nwherever the \nFileContentRepository\n is \n@Autowired\n.\n\n\n\n\n\n\nHowever, unlike our \nFileRepository\n we haven't annotated this as a\n\nStoreRestResource\n and therefore we don't automatically get REST\nendpoints for handling content.  This annotation does exist (and is the\ntopic of our \nnext tutorial\n) but, for now,\nwe have to roll our own REST endpoints.\n\n\nCreate a File Controller\n\n\nLet's create these endpoints with a simple Controller class.\n\n\nsrc/main/java/gettingstarted/FileContentController.java\n\n\npackage gettingstarted;\n\nimport java.io.IOException;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.core.io.InputStreamResource;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.multipart.MultipartFile;\n\n@RestController\npublic class FileContentController {\n\n    @Autowired private FileRepository filesRepo;\n    @Autowired private FileContentStore contentStore;\n\n    @RequestMapping(value=\n/files/{fileId}\n, method = RequestMethod.PUT)\n    public ResponseEntity\n?\n setContent(@PathVariable(\nfileId\n) Long id, @RequestParam(\nfile\n) MultipartFile file)\n            throws IOException {\n\n        Optional\nFile\n f = filesRepo.findById(id);\n        if (f.isPresent()) {\n            f.get().setMimeType(file.getContentType());\n\n            contentStore.setContent(f.get(), file.getInputStream());\n\n            // save updated content-related info\n            filesRepo.save(f.get());\n\n            return new ResponseEntity\nObject\n(HttpStatus.OK);\n        }\n        return null;\n    }\n\n    @RequestMapping(value=\n/files/{fileId}\n, method = RequestMethod.GET)\n    public ResponseEntity\n?\n getContent(@PathVariable(\nfileId\n) Long id) {\n\n        Optional\nFile\n f = filesRepo.findById(id);\n        if (f.isPresent()) {\n            InputStreamResource inputStreamResource = new InputStreamResource(contentStore.getContent(f.get()));\n            HttpHeaders headers = new HttpHeaders();\n            headers.setContentLength(f.get().getContentLength());\n            headers.set(\nContent-Type\n, f.get().getMimeType());\n            return new ResponseEntity\nObject\n(inputStreamResource, headers, HttpStatus.OK);\n        }\n        return null;\n    }\n}\n\n\n\n\nLet's explain this class.  \n\n\n\n\n\n\nIt's a standard Spring Controller with two request mapped methods, one for setting content and the other for getting content.\n\n\n\n\n\n\nBoth \nsetContent\n and \ngetContent\n methods inject themselves into the URI space of the \nFileRepository\n, namely \n/files/{fileId}\n, but handle all GETs and PUTs that are aplication/hal+json based; i.e. content.\n\n\n\n\n\n\nWe inject our \nFileRepository\n and our \nFileContentStore\n.  Respectively, Spring Boot will ensure real implementations are injected (based on what Spring Data and Spring Content modules are found on the class path).\n\n\n\n\n\n\nsetContent\n uses the \nFileRepository\n to fetch the File entity  using the given \nfileId\n and then uses the \nFileContentStore\n to save the given file input stream.  \n\n\n\n\n\n\nSimilarly, \ngetContent\n uses the \nFileRepository\n to fetch the File entity using the given \nfileId\n and again use the \nFileContentStore\n to fetch the associated content and stream it back to the client as the response.  We also use previosuly saved metdata \ncontentLength\n and \nmimeType\n to set http headers appropriately.  This will mean that browsers can handle the content correctly by launching the relevant desktop application.\n\n\n\n\n\n\nCreate Web Client\n\n\nNow let's create a really simple angular web front-end for our document list.  \n\n\nsrc/main/resources/static/index.html\n\n\n!doctype html\n\n\nhtml ng-app=\nfilesApp\n\n  \nhead\n\n    \nscript src=\nhttps://ajax.googleapis.com/ajax/libs/angularjs/1.5.8/angular.min.js\n/script\n\n    \nscript src=\nfiles.js\n/script\n\n  \n/head\n\n  \nbody\n\n    \ndiv ng-controller=\nFilesListController as filesList\n\n        \nh1\nFiles\n/h1\n\n\n        \nsection style=\ndisplay: table; width: 80%\n\n          \nheader style=\ndisplay: table-row;\n\n            \ndiv style=\ndisplay: table-cell;\nName\n/div\n\n            \ndiv style=\ndisplay: table-cell;\nLength\n/div\n\n            \ndiv style=\ndisplay: table-cell;\nCreated\n/div\n\n            \ndiv style=\ndisplay: table-cell;\nSummary\n/div\n\n          \n/header\n\n          \ndiv style=\ndisplay: table-row;\n ng-repeat=\nfile in filesList.files\n\n            \ndiv style=\ndisplay: table-cell;\na href=\n{{filesList.getHref(file)}}\n type={{file.mimeType}} download={{file.name}}\n{{file.name}}\n/a\n/div\n\n            \ndiv style=\ndisplay: table-cell;\nlabel\n{{file.contentLength}}\n/label\n/div\n\n            \ndiv style=\ndisplay: table-cell;\nlabel\n{{file.created}}\n/label\n/div\n\n            \ndiv style=\ndisplay: table-cell;\nlabel\n{{file.summary}}\n/label\n/div\n\n          \n/div\n\n        \n/section\n\n\n        \nh2\nNew File\n/h2\n\n        \ninput type=\nfile\n id=\nfile\n name=\nfile\n/\n\n        \ninput type=\nsummary\n id=\nsummary\n name=\nsummary\n ng-model=\nfilesList.summary\n placeholder=\nSummary\n/\n\n        \nbutton ng-click=\nfilesList.upload()\nUpload\n/button\n\n    \n/div\n\n  \n/body\n\n\n/html\n\n\n\n\n\nThis HTML presents a simple list of files using an \nng-repeat\n directive and contains a simple form allowing new files to be uploaded.\n\n\nAll the interesting code is in the code-behind file so add the following code behind to \nsrc/main/resources/static/files.js\n\n\nangular.module('filesApp', [])\n  .controller('FilesListController', function($http) {\n    var filesList = this;\n    filesList.files = [];\n\n    filesList.getFilesList = function() {\n        $http.get('/files/').\n            success(function(data, status, headers, config) {\n                if (data._embedded != undefined) {\n                    filesList.files = [];\n                    angular.forEach(data._embedded.files, function(file) {\n                        filesList.files.push(file);\n                    });\n                }\n            });\n        };\n    filesList.getFilesList();\n\n    filesList.getHref = function(file) {\n        return file._links[\nself\n].href\n    };\n\n    filesList.upload = function() {\n        var f = document.getElementById('file').files[0];\n        var file = {name: f.name, summary: filesList.summary};\n\n        $http.post('/files/', file).\n            then(function(response) {\n                var fd = new FormData();\n                fd.append('file', f);\n                return $http.put(response.headers(\nLocation\n), fd, {\n                    transformRequest: angular.identity,\n                    headers: {'Content-Type': undefined}\n                });\n            })\n            .then(function(response) {\n                filesList.title = \n;\n                filesList.keywords = \n;\n                filesList.getFilesList();\n                document.getElementById('file').files[0] = undefined;\n            });\n    }\n  });\n\n\n\n\nThis angular controller has the following functions:-\n\n\n\n\n\n\ngetFilesList\n queries our \nFileRepository\n via its REST endpoint \nfiles/\n\nand populates \nfilesList.files\n (presented by the \nng-repeat\n directive\nin the HTML)\n\n\n\n\n\n\ngetHref\n returns a \nfile\n's content hyperlink \nfiles/{fileId}\n (that\nultimately calls \nFileContentController.getContent\n)\n\n\n\n\n\n\nupload\n uploads a new File by first \nPOST\ning to the \nFileRepository\n\nREST endpoints \n/files\n and once created  \nPUT\ning the actual content to\nthe Files content REST endpoint \nfiles/{fileId}\n (that ultimately calls\n\nFileContentController.setContent\n)\n\n\n\n\n\n\nCreate an Application class\n\n\nOur simple document list app is now complete.  All that remains is to add the usual Spring Boot Application class.\n\n\nsrc/main/java/gettingstarted/SpringContentApplication.java\n\n\npackage gettingstarted;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class SpringContentApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringContentApplication.class, args);\n    }\n}\n\n\n\n\nBuild an executable JAR\n\n\nIf you are using Maven, you can run the application using\n\nmvn spring-boot:run\n.  Or you can build the JAR file with\n\nmvn clean package\n and run the JAR by typing:\n\n\njava -jar target/gettingstarted-spring-content-fs-0.0.1.jar\n\n\nAnd then point your browser at:-\n\n\nhttp://localhost:8080\n\n\nand you should see something like this:-\n\n\n\n\nExercise the application by uploading a range of new files and viewing\nthem.  Viewed files will be downloaded and open in the appropriate editor.\n\n\nSummary\n\n\nCongratulations! You\u2019ve written a simple application that uses Spring\nContent to manage streams of binary data - without writing any specific\nfile access code.  What's more by just changing the type of the\nspring-content boot-starter project on the classpath you can switch from\na file-based implementation to a different implementation altogether.\n\n\nSpring Content supports the following implementations:-\n\n\n\n\n\n\nSpring Content Filesystem; stores content as Files on the Filesystem\n(as used in this tutorial)\n\n\n\n\n\n\nSpring Content S3; stores content as Objects in Amazon S3\n\n\n\n\n\n\nSpring Content JPA; stores content as BLOBs in the database\n\n\n\n\n\n\nSpring Content MongoDB; stores content as Resources in Mongo's GridFS\n\n\n\n\n\n\nLook Forward\n\n\nIn this tutorial we built a simple document list web application using\nSpring Content.\n\n\nThe majority of the work on the server-side was writing the Spring\ncontroller for handling the Content.  Check out our next\n\ngetting started guide\n where we'll use the\ncompanion library Spring Content REST to automatically export these REST\nendpoints for our \nFileContentStore\n saving ourselves even more work.", 
            "title": "Basics"
        }, 
        {
            "location": "/spring-content-fs-docs/#getting-started-with-spring-content", 
            "text": "", 
            "title": "Getting Started with Spring Content"
        }, 
        {
            "location": "/spring-content-fs-docs/#what-youll-build", 
            "text": "You'll build an application that uses Spring Content to build a simple web-based document list.", 
            "title": "What you'll build"
        }, 
        {
            "location": "/spring-content-fs-docs/#what-youll-need", 
            "text": "About 30 minutes    A favorite text editor or IDE    JDK 1.8 or later    Maven 3.0+    You can also import the code from this guide as well as view the web page directly into Spring Tool Suite (STS) and work your way through it from there.", 
            "title": "What you'll need"
        }, 
        {
            "location": "/spring-content-fs-docs/#how-to-complete-this-guide", 
            "text": "Like most Spring Getting Started guides, you can start form scratch and complete each step, or you can bypass basic setup steps that are already familiar to you.  Either way, you end up with working code.  To start from scratch, move on to Build with Maven.  To skip the basics, do the following:    Download and unzip the source repository for this guide, or clone it using Git:  git clone https://github.com/paulcwarren/spring-content-gettingstarted.git    cd  into  spring-content-gettingstarted/spring-content-fs/initial    Jump ahead to  Define a simple entity .\nWhen you\u2019re finished, you can check your results against the code in  spring-content-gettingstarted/spring-content-fs/complete .", 
            "title": "How to complete this guide"
        }, 
        {
            "location": "/spring-content-fs-docs/#build-with-maven", 
            "text": "First you set up a basic build script. You can use any build system you like when building apps with Spring, but the code you need to work with  Maven  is included here.  If you\u2019re not familiar with Maven, refer to  Building Java Projects with Maven .", 
            "title": "Build with Maven"
        }, 
        {
            "location": "/spring-content-fs-docs/#create-a-directory-structure", 
            "text": "In a project directory of your choosing, create the following subdirectory structure; for example, with  mkdir -p src/main/java/gettingstarted  on *nix systems:  \u221f src\n   \u221f main\n       \u221f java\n           \u221f gettingstarted\n       \u221f resources\n           \u221f static  pom.xml  ?xml version= 1.0  encoding= UTF-8 ?  project xmlns= http://maven.apache.org/POM/4.0.0  xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance \n    xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd \n     modelVersion 4.0.0 /modelVersion \n\n     groupId com.github.paulcwarren /groupId \n     artifactId gettingstarted-spring-content-fs /artifactId \n     version 0.0.1 /version \n     packaging jar /packaging \n\n     parent \n         groupId org.springframework.boot /groupId \n         artifactId spring-boot-starter-parent /artifactId \n         version 2.0.6.RELEASE /version \n     /parent \n\n     properties \n         project.build.sourceEncoding UTF-8 /project.build.sourceEncoding \n         java.version 1.8 /java.version \n     /properties \n\n     dependencies \n         dependency \n             groupId org.springframework.boot /groupId \n             artifactId spring-boot-starter-web /artifactId \n         /dependency \n         dependency \n             groupId org.springframework.boot /groupId \n             artifactId spring-boot-starter-data-jpa /artifactId \n         /dependency \n         dependency \n             groupId com.h2database /groupId \n             artifactId h2 /artifactId \n         /dependency \n         dependency \n             groupId org.springframework.boot /groupId \n             artifactId spring-boot-starter-data-rest /artifactId \n         /dependency \n         dependency \n             groupId com.github.paulcwarren /groupId \n             artifactId spring-content-fs-boot-starter /artifactId \n             version 0.5.0 /version \n         /dependency \n     /dependencies \n\n     build \n         plugins \n             plugin \n                 groupId org.springframework.boot /groupId \n                 artifactId spring-boot-maven-plugin /artifactId \n             /plugin \n         /plugins \n     /build  /project   We add several dependencies:-    Spring Boot Starter Web provides the web server framework    Spring Boot Starter Data JPA will provide a relational database to\nstore the metadata of our files.  In this case we are using the H2\nin-memory database    Spring Boot Starter Data REST will provide REST endpoints for our File\nmetadata    Spring Boot Starter Content FS will provide a Filesystem-based\nstore for the content of each file and manage the\nassociation with an Entity", 
            "title": "Create a directory structure"
        }, 
        {
            "location": "/spring-content-fs-docs/#define-a-simple-entity", 
            "text": "Let's define a simple Entity to represent a File.  src/main/java/gettingstarted/File.java  package gettingstarted;\n\nimport java.util.Date;\n\nimport javax.persistence.Entity;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.GenerationType;\nimport javax.persistence.Id;\n\nimport org.springframework.content.commons.annotations.ContentId;\nimport org.springframework.content.commons.annotations.ContentLength;\n\n@Entity\npublic class File {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long id;\n    private String name;\n    private Date created = new Date();\n    private String summary;\n\n    @ContentId private String contentId;\n    @ContentLength private long contentLength;\n    private String mimeType =  text/plain ;\n\n    public Long getId() {\n        return id;\n    }\n\n    public void setId(Long id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Date getCreated() {\n        return created;\n    }\n\n    public void setCreated(Date created) {\n        this.created = created;\n    }\n\n    public String getSummary() {\n        return summary;\n    }\n\n    public void setSummary(String summary) {\n        this.summary = summary;\n    }\n\n    public String getContentId() {\n        return contentId;\n    }\n\n    public void setContentId(String contentId) {\n        this.contentId = contentId;\n    }\n\n    public long getContentLength() {\n        return contentLength;\n    }\n\n    public void setContentLength(long contentLength) {\n        this.contentLength = contentLength;\n    }\n\n    public String getMimeType() {\n        return mimeType;\n    }\n\n    public void setMimeType(String mimeType) {\n        this.mimeType = mimeType;\n    }\n}  As you would expect we created a standard JPA Entity to capture some metadata about our file;  name  and  summary .  In addition, because we will be serving these files over the web, we also record  mimeType  so that we can instruct the browser correctly.  We then add two annotated Spring Content fields;  @ContentId  and  @ContentLength .   @ContentId  allows us to associate a stream of binary data with an Entity and  @ContentLength  records the length of that stream.  These will be automatically managed by Spring Content.", 
            "title": "Define a simple Entity"
        }, 
        {
            "location": "/spring-content-fs-docs/#create-a-file-repository", 
            "text": "Next, as you would also expect, we create a  CrudRepository  for handling File entities and we export it as a  @RepositoryRestResource  so, for the cost of writing just one interface and annotating it, we get the ability to create, read, update and delete File entities using REST endpoints.   NB. For more information on Spring Data JPA and Spring Data REST see their respective spring.io getting started guides.   src/main/java/gettingstated/FileRepository.java  package gettingstarted;\n\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.rest.core.annotation.RepositoryRestResource;\n\n@RepositoryRestResource(path= files , collectionResourceRel= files )\npublic interface FileRepository extends JpaRepository File, Long  {\n}", 
            "title": "Create a File Repository"
        }, 
        {
            "location": "/spring-content-fs-docs/#create-a-file-content-store", 
            "text": "Similarly, we then create a  ContentStore  for handling content associated with the File entity.  src/main/java/gettngstarted/FileContentStore.java  package gettingstarted;\n\nimport org.springframework.content.commons.repository.ContentStore;\n\npublic interface FileContentStore extends ContentStore File, String  {\n}  Let's investigate this interface:-    ContentStore  provides several methods for handling content; setContent,\ngetContent and unsetContent    The dependency  com.github.paulcwarren:spring-content-fs-boot-starter \nprovides a Filesystem-based implementation of this interface and Spring\nContent auto-configuration ensures that this implementation will be used\nwherever the  FileContentRepository  is  @Autowired .    However, unlike our  FileRepository  we haven't annotated this as a StoreRestResource  and therefore we don't automatically get REST\nendpoints for handling content.  This annotation does exist (and is the\ntopic of our  next tutorial ) but, for now,\nwe have to roll our own REST endpoints.", 
            "title": "Create a File Content Store"
        }, 
        {
            "location": "/spring-content-fs-docs/#create-a-file-controller", 
            "text": "Let's create these endpoints with a simple Controller class.  src/main/java/gettingstarted/FileContentController.java  package gettingstarted;\n\nimport java.io.IOException;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.core.io.InputStreamResource;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.multipart.MultipartFile;\n\n@RestController\npublic class FileContentController {\n\n    @Autowired private FileRepository filesRepo;\n    @Autowired private FileContentStore contentStore;\n\n    @RequestMapping(value= /files/{fileId} , method = RequestMethod.PUT)\n    public ResponseEntity ?  setContent(@PathVariable( fileId ) Long id, @RequestParam( file ) MultipartFile file)\n            throws IOException {\n\n        Optional File  f = filesRepo.findById(id);\n        if (f.isPresent()) {\n            f.get().setMimeType(file.getContentType());\n\n            contentStore.setContent(f.get(), file.getInputStream());\n\n            // save updated content-related info\n            filesRepo.save(f.get());\n\n            return new ResponseEntity Object (HttpStatus.OK);\n        }\n        return null;\n    }\n\n    @RequestMapping(value= /files/{fileId} , method = RequestMethod.GET)\n    public ResponseEntity ?  getContent(@PathVariable( fileId ) Long id) {\n\n        Optional File  f = filesRepo.findById(id);\n        if (f.isPresent()) {\n            InputStreamResource inputStreamResource = new InputStreamResource(contentStore.getContent(f.get()));\n            HttpHeaders headers = new HttpHeaders();\n            headers.setContentLength(f.get().getContentLength());\n            headers.set( Content-Type , f.get().getMimeType());\n            return new ResponseEntity Object (inputStreamResource, headers, HttpStatus.OK);\n        }\n        return null;\n    }\n}  Let's explain this class.      It's a standard Spring Controller with two request mapped methods, one for setting content and the other for getting content.    Both  setContent  and  getContent  methods inject themselves into the URI space of the  FileRepository , namely  /files/{fileId} , but handle all GETs and PUTs that are aplication/hal+json based; i.e. content.    We inject our  FileRepository  and our  FileContentStore .  Respectively, Spring Boot will ensure real implementations are injected (based on what Spring Data and Spring Content modules are found on the class path).    setContent  uses the  FileRepository  to fetch the File entity  using the given  fileId  and then uses the  FileContentStore  to save the given file input stream.      Similarly,  getContent  uses the  FileRepository  to fetch the File entity using the given  fileId  and again use the  FileContentStore  to fetch the associated content and stream it back to the client as the response.  We also use previosuly saved metdata  contentLength  and  mimeType  to set http headers appropriately.  This will mean that browsers can handle the content correctly by launching the relevant desktop application.", 
            "title": "Create a File Controller"
        }, 
        {
            "location": "/spring-content-fs-docs/#create-web-client", 
            "text": "Now let's create a really simple angular web front-end for our document list.    src/main/resources/static/index.html  !doctype html  html ng-app= filesApp \n   head \n     script src= https://ajax.googleapis.com/ajax/libs/angularjs/1.5.8/angular.min.js /script \n     script src= files.js /script \n   /head \n   body \n     div ng-controller= FilesListController as filesList \n         h1 Files /h1 \n\n         section style= display: table; width: 80% \n           header style= display: table-row; \n             div style= display: table-cell; Name /div \n             div style= display: table-cell; Length /div \n             div style= display: table-cell; Created /div \n             div style= display: table-cell; Summary /div \n           /header \n           div style= display: table-row;  ng-repeat= file in filesList.files \n             div style= display: table-cell; a href= {{filesList.getHref(file)}}  type={{file.mimeType}} download={{file.name}} {{file.name}} /a /div \n             div style= display: table-cell; label {{file.contentLength}} /label /div \n             div style= display: table-cell; label {{file.created}} /label /div \n             div style= display: table-cell; label {{file.summary}} /label /div \n           /div \n         /section \n\n         h2 New File /h2 \n         input type= file  id= file  name= file / \n         input type= summary  id= summary  name= summary  ng-model= filesList.summary  placeholder= Summary / \n         button ng-click= filesList.upload() Upload /button \n     /div \n   /body  /html   This HTML presents a simple list of files using an  ng-repeat  directive and contains a simple form allowing new files to be uploaded.  All the interesting code is in the code-behind file so add the following code behind to  src/main/resources/static/files.js  angular.module('filesApp', [])\n  .controller('FilesListController', function($http) {\n    var filesList = this;\n    filesList.files = [];\n\n    filesList.getFilesList = function() {\n        $http.get('/files/').\n            success(function(data, status, headers, config) {\n                if (data._embedded != undefined) {\n                    filesList.files = [];\n                    angular.forEach(data._embedded.files, function(file) {\n                        filesList.files.push(file);\n                    });\n                }\n            });\n        };\n    filesList.getFilesList();\n\n    filesList.getHref = function(file) {\n        return file._links[ self ].href\n    };\n\n    filesList.upload = function() {\n        var f = document.getElementById('file').files[0];\n        var file = {name: f.name, summary: filesList.summary};\n\n        $http.post('/files/', file).\n            then(function(response) {\n                var fd = new FormData();\n                fd.append('file', f);\n                return $http.put(response.headers( Location ), fd, {\n                    transformRequest: angular.identity,\n                    headers: {'Content-Type': undefined}\n                });\n            })\n            .then(function(response) {\n                filesList.title =  ;\n                filesList.keywords =  ;\n                filesList.getFilesList();\n                document.getElementById('file').files[0] = undefined;\n            });\n    }\n  });  This angular controller has the following functions:-    getFilesList  queries our  FileRepository  via its REST endpoint  files/ \nand populates  filesList.files  (presented by the  ng-repeat  directive\nin the HTML)    getHref  returns a  file 's content hyperlink  files/{fileId}  (that\nultimately calls  FileContentController.getContent )    upload  uploads a new File by first  POST ing to the  FileRepository \nREST endpoints  /files  and once created   PUT ing the actual content to\nthe Files content REST endpoint  files/{fileId}  (that ultimately calls FileContentController.setContent )", 
            "title": "Create Web Client"
        }, 
        {
            "location": "/spring-content-fs-docs/#create-an-application-class", 
            "text": "Our simple document list app is now complete.  All that remains is to add the usual Spring Boot Application class.  src/main/java/gettingstarted/SpringContentApplication.java  package gettingstarted;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class SpringContentApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringContentApplication.class, args);\n    }\n}", 
            "title": "Create an Application class"
        }, 
        {
            "location": "/spring-content-fs-docs/#build-an-executable-jar", 
            "text": "If you are using Maven, you can run the application using mvn spring-boot:run .  Or you can build the JAR file with mvn clean package  and run the JAR by typing:  java -jar target/gettingstarted-spring-content-fs-0.0.1.jar  And then point your browser at:-  http://localhost:8080  and you should see something like this:-   Exercise the application by uploading a range of new files and viewing\nthem.  Viewed files will be downloaded and open in the appropriate editor.", 
            "title": "Build an executable JAR"
        }, 
        {
            "location": "/spring-content-fs-docs/#summary", 
            "text": "Congratulations! You\u2019ve written a simple application that uses Spring\nContent to manage streams of binary data - without writing any specific\nfile access code.  What's more by just changing the type of the\nspring-content boot-starter project on the classpath you can switch from\na file-based implementation to a different implementation altogether.  Spring Content supports the following implementations:-    Spring Content Filesystem; stores content as Files on the Filesystem\n(as used in this tutorial)    Spring Content S3; stores content as Objects in Amazon S3    Spring Content JPA; stores content as BLOBs in the database    Spring Content MongoDB; stores content as Resources in Mongo's GridFS", 
            "title": "Summary"
        }, 
        {
            "location": "/spring-content-fs-docs/#look-forward", 
            "text": "In this tutorial we built a simple document list web application using\nSpring Content.  The majority of the work on the server-side was writing the Spring\ncontroller for handling the Content.  Check out our next getting started guide  where we'll use the\ncompanion library Spring Content REST to automatically export these REST\nendpoints for our  FileContentStore  saving ourselves even more work.", 
            "title": "Look Forward"
        }, 
        {
            "location": "/spring-content-rest-docs/", 
            "text": "Getting Started with Spring Content REST\n\n\nWhat you'll build\n\n\nYou'll remove redundant code from the document list web application that\nwe produced in our first \nGetting Started Guide\n.\n\n\nWhat you'll need\n\n\n\n\n\n\nAbout 30 minutes\n\n\n\n\n\n\nA favorite text editor or IDE\n\n\n\n\n\n\nJDK 1.8 or later\n\n\n\n\n\n\nMaven 3.0+\n\n\n\n\n\n\nHow to complete this guide\n\n\nBefore we begin let's set up our development environment:\n\n\n\n\n\n\nDownload and unzip the source repository for this guide, or clone it\nusing Git: \ngit clone https://github.com/paulcwarren/spring-content-gettingstarted.git\n\n\n\n\n\n\nWe are going to start form where we left of in the last Getting Started\nGuide so \ncd\n into \nspring-content-gettingstarted/spring-content-fs/complete\n\n\n\n\n\n\nMove ahead to \nUpdate dependencies\n.\n\n\n\n\n\n\nWhen you\u2019re finished, you can check your results against the code in\n\nspring-content-gettingstarted/spring-content-rest/complete\n.\n\n\nUpdate dependencies\n\n\nAdd the \ncom.emc.spring.content:spring-content-rest-boot-starter\n dependency.\n\n\npom.xml\n\n\nproject xmlns=\nhttp://maven.apache.org/POM/4.0.0\n xmlns:xsi=\nhttp://www.w3.org/2001/XMLSchema-instance\n xsi:schemaLocation=\nhttp://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\n\n  \nmodelVersion\n4.0.0\n/modelVersion\n\n\n  \ngroupId\ncom.emc.spring.content\n/groupId\n\n  \nartifactId\nspring-content-rest-gettingstarted\n/artifactId\n\n  \nversion\n0.0.1\n/version\n\n\n    \nparent\n\n        \ngroupId\norg.springframework.boot\n/groupId\n\n        \nartifactId\nspring-boot-starter-parent\n/artifactId\n\n        \nversion\n2.0.6.RELEASE\n/version\n\n    \n/parent\n\n\n    \nproperties\n\n        \nproject.build.sourceEncoding\nUTF-8\n/project.build.sourceEncoding\n\n        \njava.version\n1.8\n/java.version\n\n    \n/properties\n\n\n    \ndependencies\n\n        \ndependency\n\n            \ngroupId\norg.springframework.boot\n/groupId\n\n            \nartifactId\nspring-boot-starter-web\n/artifactId\n\n        \n/dependency\n\n        \ndependency\n\n            \ngroupId\norg.springframework.boot\n/groupId\n\n            \nartifactId\nspring-boot-starter-data-jpa\n/artifactId\n\n        \n/dependency\n\n        \ndependency\n\n            \ngroupId\ncom.h2database\n/groupId\n\n            \nartifactId\nh2\n/artifactId\n\n        \n/dependency\n\n        \ndependency\n\n            \ngroupId\norg.springframework.boot\n/groupId\n\n            \nartifactId\nspring-boot-starter-data-rest\n/artifactId\n\n        \n/dependency\n\n        \ndependency\n\n            \ngroupId\ncom.github.paulcwarren\n/groupId\n\n            \nartifactId\nspring-content-fs-boot-starter\n/artifactId\n\n            \nversion\n0.5.0\n/version\n\n        \n/dependency\n\n        \ndependency\n\n            \ngroupId\ncom.github.paulcwarren\n/groupId\n\n            \nartifactId\nspring-content-rest-boot-starter\n/artifactId\n\n            \nversion\n0.5.0\n/version\n\n        \n/dependency\n\n    \n/dependencies\n\n\n    \nbuild\n\n        \nplugins\n\n            \nplugin\n\n                \ngroupId\norg.springframework.boot\n/groupId\n\n                \nartifactId\nspring-boot-maven-plugin\n/artifactId\n\n            \n/plugin\n\n        \n/plugins\n\n    \n/build\n\n\n\n/project\n\n\n\n\n\nUpdate File Entity\n\n\nAdd the \n@MimeType\n marker annotation to our Entity.\n\n\nsrc/main/java/gettingstarted/File.java\n\n\npackage gettingstarted;\n\nimport java.util.Date;\n\nimport javax.persistence.Entity;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.GenerationType;\nimport javax.persistence.Id;\n\nimport org.springframework.content.commons.annotations.ContentId;\nimport org.springframework.content.commons.annotations.ContentLength;\nimport org.springframework.content.commons.annotations.MimeType;\n\n@Entity\npublic class File {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long id;\n    private String name;\n    private Date created = new Date();\n    private String summary;\n\n    @ContentId private String contentId;\n    @ContentLength private long contentLength;\n    @MimeType private String mimeType = \ntext/plain\n;\n\n    ...Getters and setters...\n}\n\n\n\n\nThe \nmimeType\n attribute is updated with the Spring Content  \n@MimeType\n\nannotation so that Spring Content REST will update its value on our behalf.\n\n\nUpdate FileContentStore\n\n\nSo that we can perform simple CRUD operations, over a hypermedia-based\nAPI, update our \nFileContentStore\n by annotating it with the\n\n@StoreRestResource\n Spring Content REST annotation.\n\n\nsrc/main/java/gettingstarted/FileContentStore.java\n\n\npackage gettingstarted;\n\nimport org.springframework.content.commons.repository.ContentStore;\nimport org.springframework.content.rest.StoreRestResource;\n\n@StoreRestResource\npublic interface FileContentStore extends ContentStore\nFile, String\n {\n}\n\n\n\n\nRemove FileContentController\n\n\nHaving made the above updates we can remove our \nFileContentController\n\nas it is now surplus to requirements.   Spring Content REST will provide\nthese endpoints for us.\n\n\nBuild an executable JAR\n\n\nIf you are using Maven, you can run the application using \nmvn spring-boot:run\n.\nOr you can build the JAR file with \nmvn clean package\n and run the JAR\nby typing:\n\n\njava -jar target/gettingstarted-spring-content-rest-0.0.1.jar\n\n\nAnd then point your browser at:-\n\n\nhttp://localhost:8080\n\n\nand you should see something like this:-\n\n\n\n\nAs you did in the previous tutorial, exercise the application by uploading\na range of new files and viewing them.  You should see viewed files open\nas they did before.\n\n\nSummary\n\n\nCongratulations!  You've written a simple application that uses Spring\nContent and Spring Content REST to save objects with content to the\nfile-system and to fetch them again using a hypermedia-based REST API -\nall without writing any implementation code to handle file access.\n\n\nDon't forget you can just changing the type of the spring-content boot-starter\nproject on the classpath you can switch from file-based to a different\nimplementation.  Spring Content REST works seamlessly with all modules.\n\n\nSpring Content supports the following implementations:-\n\n\n\n\n\n\nSpring Content Filesystem; stores content as Files on the Filesystem\n(as used in this tutorial)\n\n\n\n\n\n\nSpring Content S3; stores content as Objects in Amazon S3\n\n\n\n\n\n\nSpring Content JPA; stores content as BLOBs in the database\n\n\n\n\n\n\nSpring Content MongoDB; stores content as Resources in Mongo's GridFS", 
            "title": "REST"
        }, 
        {
            "location": "/spring-content-rest-docs/#getting-started-with-spring-content-rest", 
            "text": "", 
            "title": "Getting Started with Spring Content REST"
        }, 
        {
            "location": "/spring-content-rest-docs/#what-youll-build", 
            "text": "You'll remove redundant code from the document list web application that\nwe produced in our first  Getting Started Guide .", 
            "title": "What you'll build"
        }, 
        {
            "location": "/spring-content-rest-docs/#what-youll-need", 
            "text": "About 30 minutes    A favorite text editor or IDE    JDK 1.8 or later    Maven 3.0+", 
            "title": "What you'll need"
        }, 
        {
            "location": "/spring-content-rest-docs/#how-to-complete-this-guide", 
            "text": "Before we begin let's set up our development environment:    Download and unzip the source repository for this guide, or clone it\nusing Git:  git clone https://github.com/paulcwarren/spring-content-gettingstarted.git    We are going to start form where we left of in the last Getting Started\nGuide so  cd  into  spring-content-gettingstarted/spring-content-fs/complete    Move ahead to  Update dependencies .    When you\u2019re finished, you can check your results against the code in spring-content-gettingstarted/spring-content-rest/complete .", 
            "title": "How to complete this guide"
        }, 
        {
            "location": "/spring-content-rest-docs/#update-dependencies", 
            "text": "Add the  com.emc.spring.content:spring-content-rest-boot-starter  dependency.  pom.xml  project xmlns= http://maven.apache.org/POM/4.0.0  xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance  xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd \n   modelVersion 4.0.0 /modelVersion \n\n   groupId com.emc.spring.content /groupId \n   artifactId spring-content-rest-gettingstarted /artifactId \n   version 0.0.1 /version \n\n     parent \n         groupId org.springframework.boot /groupId \n         artifactId spring-boot-starter-parent /artifactId \n         version 2.0.6.RELEASE /version \n     /parent \n\n     properties \n         project.build.sourceEncoding UTF-8 /project.build.sourceEncoding \n         java.version 1.8 /java.version \n     /properties \n\n     dependencies \n         dependency \n             groupId org.springframework.boot /groupId \n             artifactId spring-boot-starter-web /artifactId \n         /dependency \n         dependency \n             groupId org.springframework.boot /groupId \n             artifactId spring-boot-starter-data-jpa /artifactId \n         /dependency \n         dependency \n             groupId com.h2database /groupId \n             artifactId h2 /artifactId \n         /dependency \n         dependency \n             groupId org.springframework.boot /groupId \n             artifactId spring-boot-starter-data-rest /artifactId \n         /dependency \n         dependency \n             groupId com.github.paulcwarren /groupId \n             artifactId spring-content-fs-boot-starter /artifactId \n             version 0.5.0 /version \n         /dependency \n         dependency \n             groupId com.github.paulcwarren /groupId \n             artifactId spring-content-rest-boot-starter /artifactId \n             version 0.5.0 /version \n         /dependency \n     /dependencies \n\n     build \n         plugins \n             plugin \n                 groupId org.springframework.boot /groupId \n                 artifactId spring-boot-maven-plugin /artifactId \n             /plugin \n         /plugins \n     /build  /project", 
            "title": "Update dependencies"
        }, 
        {
            "location": "/spring-content-rest-docs/#update-file-entity", 
            "text": "Add the  @MimeType  marker annotation to our Entity.  src/main/java/gettingstarted/File.java  package gettingstarted;\n\nimport java.util.Date;\n\nimport javax.persistence.Entity;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.GenerationType;\nimport javax.persistence.Id;\n\nimport org.springframework.content.commons.annotations.ContentId;\nimport org.springframework.content.commons.annotations.ContentLength;\nimport org.springframework.content.commons.annotations.MimeType;\n\n@Entity\npublic class File {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long id;\n    private String name;\n    private Date created = new Date();\n    private String summary;\n\n    @ContentId private String contentId;\n    @ContentLength private long contentLength;\n    @MimeType private String mimeType =  text/plain ;\n\n    ...Getters and setters...\n}  The  mimeType  attribute is updated with the Spring Content   @MimeType \nannotation so that Spring Content REST will update its value on our behalf.", 
            "title": "Update File Entity"
        }, 
        {
            "location": "/spring-content-rest-docs/#update-filecontentstore", 
            "text": "So that we can perform simple CRUD operations, over a hypermedia-based\nAPI, update our  FileContentStore  by annotating it with the @StoreRestResource  Spring Content REST annotation.  src/main/java/gettingstarted/FileContentStore.java  package gettingstarted;\n\nimport org.springframework.content.commons.repository.ContentStore;\nimport org.springframework.content.rest.StoreRestResource;\n\n@StoreRestResource\npublic interface FileContentStore extends ContentStore File, String  {\n}", 
            "title": "Update FileContentStore"
        }, 
        {
            "location": "/spring-content-rest-docs/#remove-filecontentcontroller", 
            "text": "Having made the above updates we can remove our  FileContentController \nas it is now surplus to requirements.   Spring Content REST will provide\nthese endpoints for us.", 
            "title": "Remove FileContentController"
        }, 
        {
            "location": "/spring-content-rest-docs/#build-an-executable-jar", 
            "text": "If you are using Maven, you can run the application using  mvn spring-boot:run .\nOr you can build the JAR file with  mvn clean package  and run the JAR\nby typing:  java -jar target/gettingstarted-spring-content-rest-0.0.1.jar  And then point your browser at:-  http://localhost:8080  and you should see something like this:-   As you did in the previous tutorial, exercise the application by uploading\na range of new files and viewing them.  You should see viewed files open\nas they did before.", 
            "title": "Build an executable JAR"
        }, 
        {
            "location": "/spring-content-rest-docs/#summary", 
            "text": "Congratulations!  You've written a simple application that uses Spring\nContent and Spring Content REST to save objects with content to the\nfile-system and to fetch them again using a hypermedia-based REST API -\nall without writing any implementation code to handle file access.  Don't forget you can just changing the type of the spring-content boot-starter\nproject on the classpath you can switch from file-based to a different\nimplementation.  Spring Content REST works seamlessly with all modules.  Spring Content supports the following implementations:-    Spring Content Filesystem; stores content as Files on the Filesystem\n(as used in this tutorial)    Spring Content S3; stores content as Objects in Amazon S3    Spring Content JPA; stores content as BLOBs in the database    Spring Content MongoDB; stores content as Resources in Mongo's GridFS", 
            "title": "Summary"
        }
    ]
}