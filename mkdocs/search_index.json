{
    "docs": [
        {
            "location": "/", 
            "text": "Spring-Content\n\n\nExtensions for Spring-Data that add primitives for handling BLOBs, in the same Developer-friendly way that you handle your structured data.\n\n\nSpring Content provides modules for JPA, MongoDB, S3 and the Filesystem.\n\n\nQuick Start\n\n\nFor a quick taste, look at the following domain object:\n\n\n@Entity\n@Content\npublic class SopDocument {\n\n    private @Id @GeneratedValue Long id;\n    private String title;\n    private String[] authors, keywords;\n    private @ContentId String contentId\n\n    private SopDocument() {}\n    public SopDocument(String title, String[] authors, String[] keywords)   {\n        this.title = title;\n        this.authors = authors;\n        this.keywords = keywords;\n    }\n}\n\n\n\n\nThis defines a simple JPA entity with a few structured data fields; title, authors and keywords and one BLOB field denoted by the @ContentId field.  The structured data fields are handled in the usual way through a \nCrudRepository\nSopDocument,String\n interface.  The BLOB field is handled separately with a ContentRepository interface:-\n\n\npublic interface ContentRepository extends ContentRepository\nSopDocument, String\n {\n}\n\n\n\n\nThis interface extends Spring Content\u2019s ContentRepository and defines the type (SopDocument) and the id type (String).  Put this code inside a Spring Boot application with spring-boot-starter-data-jpa and spring-content-jpa-boot-starter like this:\n\n\n@SpringBootApplication\npublic class MyApp {\n\n    public static void main(String[] args) {\n        SpringApplication.run(MyApp.class, args);\n    }\n}\n\n\n\n\nLaunch your app and Spring Content (having been autoconfigured by Boot) will automatically craft a concrete set of operations for handling content for this Entity:\n\n\n\n\nsetContent(S property, InputStream content)\n\n\nunsetContent(S property)\n\n\nInputStream getContent(S property)", 
            "title": "Home"
        }, 
        {
            "location": "/#spring-content", 
            "text": "Extensions for Spring-Data that add primitives for handling BLOBs, in the same Developer-friendly way that you handle your structured data.  Spring Content provides modules for JPA, MongoDB, S3 and the Filesystem.", 
            "title": "Spring-Content"
        }, 
        {
            "location": "/#quick-start", 
            "text": "For a quick taste, look at the following domain object:  @Entity\n@Content\npublic class SopDocument {\n\n    private @Id @GeneratedValue Long id;\n    private String title;\n    private String[] authors, keywords;\n    private @ContentId String contentId\n\n    private SopDocument() {}\n    public SopDocument(String title, String[] authors, String[] keywords)   {\n        this.title = title;\n        this.authors = authors;\n        this.keywords = keywords;\n    }\n}  This defines a simple JPA entity with a few structured data fields; title, authors and keywords and one BLOB field denoted by the @ContentId field.  The structured data fields are handled in the usual way through a  CrudRepository SopDocument,String  interface.  The BLOB field is handled separately with a ContentRepository interface:-  public interface ContentRepository extends ContentRepository SopDocument, String  {\n}  This interface extends Spring Content\u2019s ContentRepository and defines the type (SopDocument) and the id type (String).  Put this code inside a Spring Boot application with spring-boot-starter-data-jpa and spring-content-jpa-boot-starter like this:  @SpringBootApplication\npublic class MyApp {\n\n    public static void main(String[] args) {\n        SpringApplication.run(MyApp.class, args);\n    }\n}  Launch your app and Spring Content (having been autoconfigured by Boot) will automatically craft a concrete set of operations for handling content for this Entity:   setContent(S property, InputStream content)  unsetContent(S property)  InputStream getContent(S property)", 
            "title": "Quick Start"
        }, 
        {
            "location": "/spring-content-fs-docs/", 
            "text": "Getting Started with Spring Content\n\n\nWhat you'll build\n\n\nYou'll build an application that uses Spring Content to build a simple web-based document list.\n\n\nWhat you'll need\n\n\n\n\nAbout 30 minutes\n\n\nA favorite text editor or IDE\n\n\nJDK 1.8 or later\n\n\nMaven 3.0+\n\n\n\n\nYou can also import the code from this guide as well as view the web page directly into Spring Tool Suite (STS) and work your way through it from there.\n\n\nHow to complete this guide\n\n\nLike most Spring Getting Started guides, you can start form scratch and complete each step, or you can bypass basic setup steps that are already familiar to you.  Either way, you end up with working code.\n\n\nTo start from scratch, move on to Build with Maven.\n\n\nTo skip the basics, do the following:\n\n\n\n\nDownload and unzip the source repository for this guide, or clone it using Git: \ngit clone https://github.com/EMC-Dojo/spring-content-gettingstarted.git\n\n\ncd\n into \nspring-content-gettingstarted/spring-content-fs/initial\n\n\nJump ahead to \nDefine a simple entity\n.\nWhen you\u2019re finished, you can check your results against the code in \nspring-content-gettingstarted/spring-content-fs/complete\n.\n\n\n\n\nBuild with Maven\n\n\nFirst you set up a basic build script. You can use any build system you like when building apps with Spring, but the code you need to work with \nMaven\n is included here.  If you\u2019re not familiar with Maven, refer to \nBuilding Java Projects with Maven\n. \n\n\nCreate a directory structure\n\n\nIn a project directory of your choosing, create the following subdirectory structure; for example, with \nmkdir -p src/main/java/gettingstarted/springcontentfs\n on *nix systems:\n\n\n\u221f src\n   \u221f main\n       \u221f java\n           \u221f gettingstarted\n               \u221f springcontentfs\n       \u221f resources\n           \u221f static\n\n\n\n\npom.xml\n\n\n?xml version=\n1.0\n encoding=\nUTF-8\n?\n\n\nproject xmlns=\nhttp://maven.apache.org/POM/4.0.0\n xmlns:xsi=\nhttp://www.w3.org/2001/XMLSchema-instance\n\n    xsi:schemaLocation=\nhttp://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\n\n    \nmodelVersion\n4.0.0\n/modelVersion\n\n\n    \ngroupId\ncom.emc.spring.content\n/groupId\n\n    \nartifactId\ngettingstarted-spring-content-fs\n/artifactId\n\n    \nversion\n0.0.1-SNAPSHOT\n/version\n\n    \npackaging\njar\n/packaging\n\n\n    \nparent\n\n        \ngroupId\norg.springframework.boot\n/groupId\n\n        \nartifactId\nspring-boot-starter-parent\n/artifactId\n\n        \nversion\n1.4.0.RELEASE\n/version\n\n    \n/parent\n\n\n    \nproperties\n\n        \nproject.build.sourceEncoding\nUTF-8\n/project.build.sourceEncoding\n\n        \njava.version\n1.8\n/java.version\n\n    \n/properties\n\n\n    \ndependencies\n\n        \ndependency\n\n            \ngroupId\norg.springframework.boot\n/groupId\n\n            \nartifactId\nspring-boot-starter-web\n/artifactId\n\n        \n/dependency\n\n        \ndependency\n\n            \ngroupId\norg.springframework.boot\n/groupId\n\n            \nartifactId\nspring-boot-starter-data-jpa\n/artifactId\n\n            \nscope\ntest\n/scope\n\n        \n/dependency\n\n        \ndependency\n\n            \ngroupId\ncom.h2database\n/groupId\n\n            \nartifactId\nh2\n/artifactId\n\n            \nscope\ntest\n/scope\n\n        \n/dependency\n\n        \ndependency\n\n            \ngroupId\ncom.emc.spring.content\n/groupId\n\n            \nartifactId\nspring-content-fs-boot-starter\n/artifactId\n\n            \nversion\n0.0.1-SNAPSHOT\n/version\n\n        \n/dependency\n\n    \n/dependencies\n\n\n    \nbuild\n\n        \nplugins\n\n            \nplugin\n\n                \ngroupId\norg.springframework.boot\n/groupId\n\n                \nartifactId\nspring-boot-maven-plugin\n/artifactId\n\n            \n/plugin\n\n        \n/plugins\n\n    \n/build\n\n\n/project\n\n\n\n\n\nWe add several dependencies:-\n\n\n\n\nSpring Boot Starter Web provides the web server framework\n\n\nSpring Boot Starter Data JPA will provide a relational database to store metadata of our files.  In this case we are using the H2 in-memory database.\n\n\nSpring Boot Starter Data REST will provide REST endpoints for our File metadata\n\n\nSpring Boot Starter Content FS will provide a Filesystem-backed content repository for the content of each file.  Content will be automatically associated this with it's owning Entity by Spring Content.\n\n\n\n\nDefine a simple Entity\n\n\nLet's define a simple Entity to represent a File.\n\n\nsrc/main/java/gettingstarted/springcontentfs/File.java\n\n\npackage gettingstarted.springcontentfs;\n\nimport java.util.Date;\n\nimport javax.persistence.Entity;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.GenerationType;\nimport javax.persistence.Id;\n\nimport com.emc.spring.content.commons.annotations.ContentId;\nimport com.emc.spring.content.commons.annotations.ContentLength;\n\n@Entity\npublic class File {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long id;\n    private String name;\n    private Date created = new Date();\n    private String summary;\n\n    @ContentId private String contentId;\n    @ContentLength private long contentLength;\n    private String mimeType = \ntext/plain\n;\n\n    public Long getId() {\n        return id;\n    }\n\n    public void setId(Long id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Date getCreated() {\n        return created;\n    }\n\n    public void setCreated(Date created) {\n        this.created = created;\n    }\n\n    public String getSummary() {\n        return summary;\n    }\n\n    public void setSummary(String summary) {\n        this.summary = summary;\n    }\n\n    public String getContentId() {\n        return contentId;\n    }\n\n    public void setContentId(String contentId) {\n        this.contentId = contentId;\n    }\n\n    public long getContentLength() {\n        return contentLength;\n    }\n\n    public void setContentLength(long contentLength) {\n        this.contentLength = contentLength;\n    }\n\n    public String getMimeType() {\n        return mimeType;\n    }\n\n    public void setMimeType(String mimeType) {\n        this.mimeType = mimeType;\n    }\n}\n\n\n\n\nAs you would expect we created a standard JPA Entity to capture some metadata about our file; \nname\n and \nsummary\n.  In addition, because we will be serving these files over the web, we also record \nmimeType\n so that we can instruct the browser correctly.\n\n\nWe then add two annotated Spring Content fields; \n@ContentId\n and \n@ContentLength\n.  \n@ContentId\n allows us to associate a stream of binary data with an Entity and \n@ContentLength\n records the length of that stream.  These will be automatically managed by Spring Content.\n\n\nCreate a File Repository\n\n\nNext, as you would also expect, we create a \nCrudRepository\n for handling File entities and we export it as a \n@RepositoryRestResource\n so, for the cost of writing just one interface (and annotating it), we get the ability to create, read, update and delete File entities using REST endpoints.\n\n\n\n\nNB. For more information on Spring Data JPA and Spring Data REST see their respective spring.io Getting Started guides.\n\n\n\n\nsrc/main/java/gettingstated/springcontentfs/FileRepoistory.java\n\n\npackage gettingstarted.springcontentfs;\n\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.rest.core.annotation.RepositoryRestResource;\n\n@RepositoryRestResource(path=\nfiles\n, collectionResourceRel=\nfiles\n)\npublic interface FileRepository extends JpaRepository\nFile, Long\n {\n\n}\n\n\n\n\nCreate a File ContentRepository\n\n\nSimilarly, we then create a \nContentRepository\n for handling content associated with the File entity.\n\n\nsrc/main/java/gettngstarted/springcontentfs/FileContentRepository.java\n\n\npackage gettingstarted.springcontentfs;\n\nimport com.emc.spring.content.commons.repository.ContentStore;\n\npublic interface FileContentRepository extends ContentStore\nFile, String\n {\n}\n\n\n\n\nLet's investigate this interface:-\n\n\n\n\nContentStore\n provides several methods for handling content; setContent, getContent and unsetContent\n\n\nThe dependency \ncom.emc.spring.content:spring-content-fs-boot-starter\n provides a Filesystem-backed implementation of this interface and Spring Boot with Spring Content together ensure that this implementation will be used wherever the \nFileContentRepository\n is \n@Autowired\n.\n\n\n\n\nCreate a File Controller\n\n\nSo now we have a way to create, read, update and delete File entities from our web UI using the \nFileRepository\n REST endpoints.  \n\n\nWe also have a way to handle content but we unlike Spring Data we don't automtically get REST endpoints for managing this content so we need to create these endpoints, using the  \nFileContentRepository\n to help us.\n\n\nsrc/main/java/gettingstarted/springcontentfs/FileContentController.java\n\n\npackage gettingstarted.springcontentfs;\n\nimport java.io.IOException;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.core.io.InputStreamResource;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.multipart.MultipartFile;\n\n@RestController\npublic class FileContentController {\n\n    @Autowired private FileRepository filesRepo;\n    @Autowired private FileContentRepository contentsRepo;\n\n    @RequestMapping(value=\n/files/{fileId}/content\n, method = RequestMethod.PUT)\n    public ResponseEntity\n?\n setContent(@PathVariable(\nfileId\n) Long id, @RequestParam(\nfile\n) MultipartFile file) \n            throws IOException {\n\n        File f = filesRepo.findOne(id);\n        f.setMimeType(file.getContentType());\n\n        // save updated content-related info\n        contentsRepo.setContent(f, file.getInputStream());\n        filesRepo.save(f);\n\n        return new ResponseEntity\nObject\n(HttpStatus.OK);\n    }\n\n    @RequestMapping(value=\n/files/{fileId}/content\n, method = RequestMethod.GET)\n    public ResponseEntity\n?\n getContent(@PathVariable(\nfileId\n) Long id) {\n\n        File f = filesRepo.findOne(id);\n        InputStreamResource inputStreamResource = new InputStreamResource(contentsRepo.getContent(f));\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentLength(f.getContentLength());\n        headers.set(\nContent-Type\n,     f.getMimeType());\n        return new ResponseEntity\nObject\n(inputStreamResource, headers, HttpStatus.OK);\n    }\n}\n\n\n\n\nLet's explain this class.  \n\n\n\n\nIt's a standard Spring Controller with two request mapped methods, one for setting content and the other for getting content. \n\n\nBoth \nsetContent\n and \ngetContent\n methods inject themselves into the URI space of the \nFileRepository\n, namely \n/files/{fileId}\n, exporting an additional \n/content\n endpoint.\n\n\nWe inject our \nFileRepository\n and our \nFileContentRepository\n.  Respectively, Spring Boot will ensure real implementations are injected (based on what Spring Data and Spring Content modules are found on the class path). \n\n\nsetContent\n uses the \nFileRepository\n to fetch the File entity  using the given \nfileId\n and then uses the \nFileContentRepository\n to save the given file input stream.  \n\n\nSimilarly, \ngetContent\n uses the \nFileRepository\n to fetch the File entity using the given \nfileId\n and again use the \nFileContentRepository\n to fetch the associated content and stream it back to the client as the response.  We also use previosuly saved metdata \ncontentLength\n and \nmimeType\n to set http headers appropriately.  This will mean that browsers can handle the content correctly by launching the relevant desktop application.\n\n\n\n\nCreate Web Client\n\n\nNow let's create a really simple angular web front-end for our document list.  \n\n\nsrc/main/resources/static/index.html\n\n\n!doctype html\n\n\nhtml ng-app=\nfilesApp\n\n  \nhead\n\n    \nscript src=\nhttps://ajax.googleapis.com/ajax/libs/angularjs/1.5.8/angular.min.js\n/script\n\n    \nscript src=\nfiles.js\n/script\n\n  \n/head\n\n  \nbody\n\n    \ndiv ng-controller=\nFilesListController as filesList\n\n        \nh1\nFiles\n/h1\n\n\n        \nsection style=\ndisplay: table; width: 80%\n\n          \nheader style=\ndisplay: table-row;\n\n            \ndiv style=\ndisplay: table-cell;\nName\n/div\n\n            \ndiv style=\ndisplay: table-cell;\nLength\n/div\n\n            \ndiv style=\ndisplay: table-cell;\nCreated\n/div\n\n            \ndiv style=\ndisplay: table-cell;\nSummary\n/div\n\n          \n/header\n\n          \ndiv style=\ndisplay: table-row;\n ng-repeat=\nfile in filesList.files\n\n            \ndiv style=\ndisplay: table-cell;\na href=\n{{filesList.getHref(file)}}\n target=\n_new\n{{file.name}}\n/a\n/div\n\n            \ndiv style=\ndisplay: table-cell;\nlabel\n{{file.contentLength}}\n/label\n/div\n\n            \ndiv style=\ndisplay: table-cell;\nlabel\n{{file.created}}\n/label\n/div\n\n            \ndiv style=\ndisplay: table-cell;\nlabel\n{{file.summary}}\n/label\n/div\n\n          \n/div\n\n        \n/section\n\n\n        \nh2\nNew File\n/h2\n\n        \ninput type=\nfile\n id=\nfile\n name=\nfile\n/\n\n        \ninput type=\nsummary\n id=\nsummary\n name=\nsummary\n ng-model=\nfilesList.summary\n placeholder=\nSummary\n/\n\n        \nbutton ng-click=\nfilesList.upload()\nUpload\n/button\n\n    \n/div\n\n  \n/body\n\n\n/html\n\n\n\n\n\nThis HTML presents a simple list of files using an \nng-repeat\n directive and contains a simple form allowing new files to be uploaded. \n\n\nAll the interesting code is in the code-behind file so add the following code behind to \nsrc/main/resources/static/files.js\n\n\nangular.module('filesApp', [])\n  .controller('FilesListController', function($http) {\n    var filesList = this;\n    filesList.files = []; \n\n    filesList.getFilesList = function() {\n        $http.get('/files/').\n            success(function(data, status, headers, config) {\n                if (data._embedded != undefined) {\n                    filesList.files = [];\n                    angular.forEach(data._embedded.files, function(file) {\n                        filesList.files.push(file);\n                    });\n                }\n            });\n        };\n    filesList.getFilesList(); \n\n    filesList.getHref = function(file) {\n        return file._links[\nself\n].href + \n/content/\n\n    };\n\n    filesList.upload = function() {\n        var f = document.getElementById('file').files[0];\n        var file = {name: f.name, summary: filesList.summary};\n\n        $http.post('/files/', file).\n            then(function(response) {\n                var fd = new FormData();\n                fd.append('file', f);\n                return $http.put(response.headers(\nLocation\n) + \n/content\n, fd, {\n                    transformRequest: angular.identity,\n                    headers: {'Content-Type': undefined}\n                });\n            })\n            .then(function(response) {\n                filesList.title = \n;\n                filesList.keywords = \n;\n                filesList.getFilesList();\n                document.getElementById('file').files[0] = undefined;\n            });\n    }\n\n  });\n\n\n\n\nThis angular controller has the following functions:-\n\n\n\n\ngetFilesList\n queries our \nFileRepository\n via its REST endpoint \nfiles/\n and adds the list of files that are returned to \nfilesList.files\n (presented by the \nng-repeat\n directive in the HTML)\n\n\ngetHref\n returns a \nfile\n's content hyperlink \nfiles/{fileId}/content/\n (that ultimately calls \nFileContentController.getContent\n) \n\n\nupload\n uploads a new File by first \nPOST\ning to the \nFileRepository\n REST endpoints \n/files\n and once created  \nPUT\ning the actual content to the Files content REST endpoint \nfiles/{fileId}/content/\n (that ultimately calls \nFileContentController.setContent\n)   \n\n\n\n\nCreate an Application class\n\n\nOur simple document list app is now complete.  All that remains is to add the usual Spring Boot Application class.\n\n\nsrc/main/java/gettingstarted/springcontentfs/SpringContentFsApplication.java\n\n\npackage gettingstarted.springcontentfs;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class SpringContentFsApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringContentFsApplication.class, args);\n    }\n}\n\n\n\n\nBuild an executable JAR\n\n\nIf you are using Maven, you can run the application using \nmvn spring-boot:run\n.  Or you can build the JAR file with \nmvn clean package\n and run the JAR by typing:\n\n\njava -jar target/gs-accessing-data-jpa-0.1.0.jar\n\n\nAnd then point your browser at:-\n\n\nhttp://localhost:8080\n \n\n\nand you should see something like this:-\n\n\n\n\nExercise the application by uploading a range of new files and viewing them.  You should see viewed files open in a new tab in their associated editor.\n\n\nSummary\n\n\nCongratulations! You\u2019ve written a simple application that uses Spring Content to manage streams of binary data -\u2009all without writing a concrete implementation.\n\n\nSpring Content supports the following implementation modules:-\n\n\n\n\nSpring Content Filesystem; stores content on the Filesystem (as used in this tutorial)\n\n\nSpring Content S3; stores content in Amazon S3\n\n\nSpring Content JPA; stores content as BLOBs in the database\n\n\nSpring Content MongoDB; stores content in Mongo's GridFs\n\n\n\n\nLook Forward\n\n\nIn this tutorial we built a simple document list web application using Spring Content.  \n\n\nThe majority of the work on the server-side was writing the Spring controller for handling the Content.  Check out our next \ngetting started guide\n where we'll use the companion library Spring Content REST to automatically export these REST endpoints for our \nFileContentRepository\n saving ourselves even more work.", 
            "title": "Getting Started with Spring Content"
        }, 
        {
            "location": "/spring-content-fs-docs/#getting-started-with-spring-content", 
            "text": "", 
            "title": "Getting Started with Spring Content"
        }, 
        {
            "location": "/spring-content-fs-docs/#what-youll-build", 
            "text": "You'll build an application that uses Spring Content to build a simple web-based document list.", 
            "title": "What you'll build"
        }, 
        {
            "location": "/spring-content-fs-docs/#what-youll-need", 
            "text": "About 30 minutes  A favorite text editor or IDE  JDK 1.8 or later  Maven 3.0+   You can also import the code from this guide as well as view the web page directly into Spring Tool Suite (STS) and work your way through it from there.", 
            "title": "What you'll need"
        }, 
        {
            "location": "/spring-content-fs-docs/#how-to-complete-this-guide", 
            "text": "Like most Spring Getting Started guides, you can start form scratch and complete each step, or you can bypass basic setup steps that are already familiar to you.  Either way, you end up with working code.  To start from scratch, move on to Build with Maven.  To skip the basics, do the following:   Download and unzip the source repository for this guide, or clone it using Git:  git clone https://github.com/EMC-Dojo/spring-content-gettingstarted.git  cd  into  spring-content-gettingstarted/spring-content-fs/initial  Jump ahead to  Define a simple entity .\nWhen you\u2019re finished, you can check your results against the code in  spring-content-gettingstarted/spring-content-fs/complete .", 
            "title": "How to complete this guide"
        }, 
        {
            "location": "/spring-content-fs-docs/#build-with-maven", 
            "text": "First you set up a basic build script. You can use any build system you like when building apps with Spring, but the code you need to work with  Maven  is included here.  If you\u2019re not familiar with Maven, refer to  Building Java Projects with Maven .", 
            "title": "Build with Maven"
        }, 
        {
            "location": "/spring-content-fs-docs/#create-a-directory-structure", 
            "text": "In a project directory of your choosing, create the following subdirectory structure; for example, with  mkdir -p src/main/java/gettingstarted/springcontentfs  on *nix systems:  \u221f src\n   \u221f main\n       \u221f java\n           \u221f gettingstarted\n               \u221f springcontentfs\n       \u221f resources\n           \u221f static  pom.xml  ?xml version= 1.0  encoding= UTF-8 ?  project xmlns= http://maven.apache.org/POM/4.0.0  xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance \n    xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd \n     modelVersion 4.0.0 /modelVersion \n\n     groupId com.emc.spring.content /groupId \n     artifactId gettingstarted-spring-content-fs /artifactId \n     version 0.0.1-SNAPSHOT /version \n     packaging jar /packaging \n\n     parent \n         groupId org.springframework.boot /groupId \n         artifactId spring-boot-starter-parent /artifactId \n         version 1.4.0.RELEASE /version \n     /parent \n\n     properties \n         project.build.sourceEncoding UTF-8 /project.build.sourceEncoding \n         java.version 1.8 /java.version \n     /properties \n\n     dependencies \n         dependency \n             groupId org.springframework.boot /groupId \n             artifactId spring-boot-starter-web /artifactId \n         /dependency \n         dependency \n             groupId org.springframework.boot /groupId \n             artifactId spring-boot-starter-data-jpa /artifactId \n             scope test /scope \n         /dependency \n         dependency \n             groupId com.h2database /groupId \n             artifactId h2 /artifactId \n             scope test /scope \n         /dependency \n         dependency \n             groupId com.emc.spring.content /groupId \n             artifactId spring-content-fs-boot-starter /artifactId \n             version 0.0.1-SNAPSHOT /version \n         /dependency \n     /dependencies \n\n     build \n         plugins \n             plugin \n                 groupId org.springframework.boot /groupId \n                 artifactId spring-boot-maven-plugin /artifactId \n             /plugin \n         /plugins \n     /build  /project   We add several dependencies:-   Spring Boot Starter Web provides the web server framework  Spring Boot Starter Data JPA will provide a relational database to store metadata of our files.  In this case we are using the H2 in-memory database.  Spring Boot Starter Data REST will provide REST endpoints for our File metadata  Spring Boot Starter Content FS will provide a Filesystem-backed content repository for the content of each file.  Content will be automatically associated this with it's owning Entity by Spring Content.", 
            "title": "Create a directory structure"
        }, 
        {
            "location": "/spring-content-fs-docs/#define-a-simple-entity", 
            "text": "Let's define a simple Entity to represent a File.  src/main/java/gettingstarted/springcontentfs/File.java  package gettingstarted.springcontentfs;\n\nimport java.util.Date;\n\nimport javax.persistence.Entity;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.GenerationType;\nimport javax.persistence.Id;\n\nimport com.emc.spring.content.commons.annotations.ContentId;\nimport com.emc.spring.content.commons.annotations.ContentLength;\n\n@Entity\npublic class File {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long id;\n    private String name;\n    private Date created = new Date();\n    private String summary;\n\n    @ContentId private String contentId;\n    @ContentLength private long contentLength;\n    private String mimeType =  text/plain ;\n\n    public Long getId() {\n        return id;\n    }\n\n    public void setId(Long id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Date getCreated() {\n        return created;\n    }\n\n    public void setCreated(Date created) {\n        this.created = created;\n    }\n\n    public String getSummary() {\n        return summary;\n    }\n\n    public void setSummary(String summary) {\n        this.summary = summary;\n    }\n\n    public String getContentId() {\n        return contentId;\n    }\n\n    public void setContentId(String contentId) {\n        this.contentId = contentId;\n    }\n\n    public long getContentLength() {\n        return contentLength;\n    }\n\n    public void setContentLength(long contentLength) {\n        this.contentLength = contentLength;\n    }\n\n    public String getMimeType() {\n        return mimeType;\n    }\n\n    public void setMimeType(String mimeType) {\n        this.mimeType = mimeType;\n    }\n}  As you would expect we created a standard JPA Entity to capture some metadata about our file;  name  and  summary .  In addition, because we will be serving these files over the web, we also record  mimeType  so that we can instruct the browser correctly.  We then add two annotated Spring Content fields;  @ContentId  and  @ContentLength .   @ContentId  allows us to associate a stream of binary data with an Entity and  @ContentLength  records the length of that stream.  These will be automatically managed by Spring Content.", 
            "title": "Define a simple Entity"
        }, 
        {
            "location": "/spring-content-fs-docs/#create-a-file-repository", 
            "text": "Next, as you would also expect, we create a  CrudRepository  for handling File entities and we export it as a  @RepositoryRestResource  so, for the cost of writing just one interface (and annotating it), we get the ability to create, read, update and delete File entities using REST endpoints.   NB. For more information on Spring Data JPA and Spring Data REST see their respective spring.io Getting Started guides.   src/main/java/gettingstated/springcontentfs/FileRepoistory.java  package gettingstarted.springcontentfs;\n\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.rest.core.annotation.RepositoryRestResource;\n\n@RepositoryRestResource(path= files , collectionResourceRel= files )\npublic interface FileRepository extends JpaRepository File, Long  {\n\n}", 
            "title": "Create a File Repository"
        }, 
        {
            "location": "/spring-content-fs-docs/#create-a-file-contentrepository", 
            "text": "Similarly, we then create a  ContentRepository  for handling content associated with the File entity.  src/main/java/gettngstarted/springcontentfs/FileContentRepository.java  package gettingstarted.springcontentfs;\n\nimport com.emc.spring.content.commons.repository.ContentStore;\n\npublic interface FileContentRepository extends ContentStore File, String  {\n}  Let's investigate this interface:-   ContentStore  provides several methods for handling content; setContent, getContent and unsetContent  The dependency  com.emc.spring.content:spring-content-fs-boot-starter  provides a Filesystem-backed implementation of this interface and Spring Boot with Spring Content together ensure that this implementation will be used wherever the  FileContentRepository  is  @Autowired .", 
            "title": "Create a File ContentRepository"
        }, 
        {
            "location": "/spring-content-fs-docs/#create-a-file-controller", 
            "text": "So now we have a way to create, read, update and delete File entities from our web UI using the  FileRepository  REST endpoints.    We also have a way to handle content but we unlike Spring Data we don't automtically get REST endpoints for managing this content so we need to create these endpoints, using the   FileContentRepository  to help us.  src/main/java/gettingstarted/springcontentfs/FileContentController.java  package gettingstarted.springcontentfs;\n\nimport java.io.IOException;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.core.io.InputStreamResource;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.multipart.MultipartFile;\n\n@RestController\npublic class FileContentController {\n\n    @Autowired private FileRepository filesRepo;\n    @Autowired private FileContentRepository contentsRepo;\n\n    @RequestMapping(value= /files/{fileId}/content , method = RequestMethod.PUT)\n    public ResponseEntity ?  setContent(@PathVariable( fileId ) Long id, @RequestParam( file ) MultipartFile file) \n            throws IOException {\n\n        File f = filesRepo.findOne(id);\n        f.setMimeType(file.getContentType());\n\n        // save updated content-related info\n        contentsRepo.setContent(f, file.getInputStream());\n        filesRepo.save(f);\n\n        return new ResponseEntity Object (HttpStatus.OK);\n    }\n\n    @RequestMapping(value= /files/{fileId}/content , method = RequestMethod.GET)\n    public ResponseEntity ?  getContent(@PathVariable( fileId ) Long id) {\n\n        File f = filesRepo.findOne(id);\n        InputStreamResource inputStreamResource = new InputStreamResource(contentsRepo.getContent(f));\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentLength(f.getContentLength());\n        headers.set( Content-Type ,     f.getMimeType());\n        return new ResponseEntity Object (inputStreamResource, headers, HttpStatus.OK);\n    }\n}  Let's explain this class.     It's a standard Spring Controller with two request mapped methods, one for setting content and the other for getting content.   Both  setContent  and  getContent  methods inject themselves into the URI space of the  FileRepository , namely  /files/{fileId} , exporting an additional  /content  endpoint.  We inject our  FileRepository  and our  FileContentRepository .  Respectively, Spring Boot will ensure real implementations are injected (based on what Spring Data and Spring Content modules are found on the class path).   setContent  uses the  FileRepository  to fetch the File entity  using the given  fileId  and then uses the  FileContentRepository  to save the given file input stream.    Similarly,  getContent  uses the  FileRepository  to fetch the File entity using the given  fileId  and again use the  FileContentRepository  to fetch the associated content and stream it back to the client as the response.  We also use previosuly saved metdata  contentLength  and  mimeType  to set http headers appropriately.  This will mean that browsers can handle the content correctly by launching the relevant desktop application.", 
            "title": "Create a File Controller"
        }, 
        {
            "location": "/spring-content-fs-docs/#create-web-client", 
            "text": "Now let's create a really simple angular web front-end for our document list.    src/main/resources/static/index.html  !doctype html  html ng-app= filesApp \n   head \n     script src= https://ajax.googleapis.com/ajax/libs/angularjs/1.5.8/angular.min.js /script \n     script src= files.js /script \n   /head \n   body \n     div ng-controller= FilesListController as filesList \n         h1 Files /h1 \n\n         section style= display: table; width: 80% \n           header style= display: table-row; \n             div style= display: table-cell; Name /div \n             div style= display: table-cell; Length /div \n             div style= display: table-cell; Created /div \n             div style= display: table-cell; Summary /div \n           /header \n           div style= display: table-row;  ng-repeat= file in filesList.files \n             div style= display: table-cell; a href= {{filesList.getHref(file)}}  target= _new {{file.name}} /a /div \n             div style= display: table-cell; label {{file.contentLength}} /label /div \n             div style= display: table-cell; label {{file.created}} /label /div \n             div style= display: table-cell; label {{file.summary}} /label /div \n           /div \n         /section \n\n         h2 New File /h2 \n         input type= file  id= file  name= file / \n         input type= summary  id= summary  name= summary  ng-model= filesList.summary  placeholder= Summary / \n         button ng-click= filesList.upload() Upload /button \n     /div \n   /body  /html   This HTML presents a simple list of files using an  ng-repeat  directive and contains a simple form allowing new files to be uploaded.   All the interesting code is in the code-behind file so add the following code behind to  src/main/resources/static/files.js  angular.module('filesApp', [])\n  .controller('FilesListController', function($http) {\n    var filesList = this;\n    filesList.files = []; \n\n    filesList.getFilesList = function() {\n        $http.get('/files/').\n            success(function(data, status, headers, config) {\n                if (data._embedded != undefined) {\n                    filesList.files = [];\n                    angular.forEach(data._embedded.files, function(file) {\n                        filesList.files.push(file);\n                    });\n                }\n            });\n        };\n    filesList.getFilesList(); \n\n    filesList.getHref = function(file) {\n        return file._links[ self ].href +  /content/ \n    };\n\n    filesList.upload = function() {\n        var f = document.getElementById('file').files[0];\n        var file = {name: f.name, summary: filesList.summary};\n\n        $http.post('/files/', file).\n            then(function(response) {\n                var fd = new FormData();\n                fd.append('file', f);\n                return $http.put(response.headers( Location ) +  /content , fd, {\n                    transformRequest: angular.identity,\n                    headers: {'Content-Type': undefined}\n                });\n            })\n            .then(function(response) {\n                filesList.title =  ;\n                filesList.keywords =  ;\n                filesList.getFilesList();\n                document.getElementById('file').files[0] = undefined;\n            });\n    }\n\n  });  This angular controller has the following functions:-   getFilesList  queries our  FileRepository  via its REST endpoint  files/  and adds the list of files that are returned to  filesList.files  (presented by the  ng-repeat  directive in the HTML)  getHref  returns a  file 's content hyperlink  files/{fileId}/content/  (that ultimately calls  FileContentController.getContent )   upload  uploads a new File by first  POST ing to the  FileRepository  REST endpoints  /files  and once created   PUT ing the actual content to the Files content REST endpoint  files/{fileId}/content/  (that ultimately calls  FileContentController.setContent )", 
            "title": "Create Web Client"
        }, 
        {
            "location": "/spring-content-fs-docs/#create-an-application-class", 
            "text": "Our simple document list app is now complete.  All that remains is to add the usual Spring Boot Application class.  src/main/java/gettingstarted/springcontentfs/SpringContentFsApplication.java  package gettingstarted.springcontentfs;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class SpringContentFsApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringContentFsApplication.class, args);\n    }\n}", 
            "title": "Create an Application class"
        }, 
        {
            "location": "/spring-content-fs-docs/#build-an-executable-jar", 
            "text": "If you are using Maven, you can run the application using  mvn spring-boot:run .  Or you can build the JAR file with  mvn clean package  and run the JAR by typing:  java -jar target/gs-accessing-data-jpa-0.1.0.jar  And then point your browser at:-  http://localhost:8080    and you should see something like this:-   Exercise the application by uploading a range of new files and viewing them.  You should see viewed files open in a new tab in their associated editor.", 
            "title": "Build an executable JAR"
        }, 
        {
            "location": "/spring-content-fs-docs/#summary", 
            "text": "Congratulations! You\u2019ve written a simple application that uses Spring Content to manage streams of binary data -\u2009all without writing a concrete implementation.  Spring Content supports the following implementation modules:-   Spring Content Filesystem; stores content on the Filesystem (as used in this tutorial)  Spring Content S3; stores content in Amazon S3  Spring Content JPA; stores content as BLOBs in the database  Spring Content MongoDB; stores content in Mongo's GridFs", 
            "title": "Summary"
        }, 
        {
            "location": "/spring-content-fs-docs/#look-forward", 
            "text": "In this tutorial we built a simple document list web application using Spring Content.    The majority of the work on the server-side was writing the Spring controller for handling the Content.  Check out our next  getting started guide  where we'll use the companion library Spring Content REST to automatically export these REST endpoints for our  FileContentRepository  saving ourselves even more work.", 
            "title": "Look Forward"
        }, 
        {
            "location": "/spring-content-rest-docs/", 
            "text": "Getting Started with Spring Content REST\n\n\nThis guide walks you through building an application that uses Spring Content to store and retrieve  content in a database.\n\n\nWhat you'll build\n\n\nYou'll build an application that stores Document POJOs in a Mongo database.\n\n\nWhat you'll need\n\n\n\n\nAbout 30 minutes\n\n\nA favorite text editor or IDE\n\n\nJDK 1.8 or later\n\n\nMaven 3.0+\n\n\nMongoDB 3.0.7\n\n\nYou can also import the code from this guide as well as view the web page directly into Spring Tool Suite (STS) and work your way through it from there.\n\n\n\n\nHow to complete this guide\n\n\nLike most Spring Getting Started guides, you can start form scratch and complete each step, or you can bypass basic setup steps that are already familiar to you. Either way, you end up with working code.\n\n\nTo start from scratch, move on to Build with Maven.\n\n\nTo skip the basics, do the following:\n\n\n\n\nDownload and unzip the source repository for this guide, or clone it using Git: \ngit clone https://github.com/EMC-Dojo/spring-gs-content.git\n\n\ncd into spring-gs-content/spring-gs-content-mongorest/initial\n\n\nJump ahead to \nDefine a simple entity\n.\nWhen you\u2019re finished, you can check your results against the code in \nspring-gs-content/spring-gs-content-mongorest/complete\n.\n\n\n\n\nBuild with Maven\n\n\nFirst you set up a basic build script. You can use any build system you like when building apps with Spring, but the code you need to work with \nMaven\n is included here. If you\u2019re not familiar with Maven, refer to \nBuilding Java Projects with Maven\n. \n\n\nCreate a directory structure\n\n\nIn a project directory of your choosing, create the following subdirectory structure; for example, with \nmkdir -p src/main/java/hello\n on *nix systems:\n\n\n\u221f src\n   \u221f main\n       \u221f java\n           \u221f docs\n\n\n\n\npom.xml\n\n\n?xml version=\"1.0\" encoding=\"UTF-8\"?\n\n\nproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\n\n    \nmodelVersion\n4.0.0\n/modelVersion\n\n\n    \ngroupId\norg.springframework.content.gs\n/groupId\n\n    \nartifactId\ngs-accessing-content-jpa\n/artifactId\n\n    \nversion\n0.1.0\n/version\n\n\n    \nparent\n\n        \ngroupId\norg.springframework.boot\n/groupId\n\n        \nartifactId\nspring-boot-starter-parent\n/artifactId\n\n        \nversion\n1.3.2.RELEASE\n/version\n\n    \n/parent\n\n\n    \ndependencies\n\n        \ndependency\n\n            \ngroupId\norg.springframework.boot\n/groupId\n\n            \nartifactId\nspring-boot-starter-data-mongodb\n/artifactId\n\n        \n/dependency\n\n        \ndependency\n\n            \ngroupId\norg.springframework.boot\n/groupId\n\n            \nartifactId\nspring-boot-starter-data-rest\n/artifactId\n\n        \n/dependency\n\n        \ndependency\n\n            \ngroupId\norg.springframework.boot\n/groupId\n\n            \nartifactId\nspring-boot-starter-web\n/artifactId\n\n        \n/dependency\n\n        \ndependency\n\n            \ngroupId\norg.springframework.boot\n/groupId\n\n            \nartifactId\nspring-content-mongo-boot-starter\n/artifactId\n\n            \nversion\n1.3.2.RELEASE\n/version\n\n        \n/dependency\n\n        \ndependency\n\n            \ngroupId\norg.springframework.boot\n/groupId\n\n            \nartifactId\nspring-content-rest-boot-starter\n/artifactId\n\n            \nversion\n1.3.2.RELEASE\n/version\n\n        \n/dependency\n\n    \n/dependencies\n\n\n    \nproperties\n\n        \njava.version\n1.8\n/java.version\n\n    \n/properties\n\n\n    \nbuild\n\n        \nplugins\n\n            \nplugin\n\n                \ngroupId\norg.springframework.boot\n/groupId\n\n                \nartifactId\nspring-boot-maven-plugin\n/artifactId\n\n            \n/plugin\n\n        \n/plugins\n\n    \n/build\n\n\n/project\n\n\n\n\nThe \nSpring Boot Maven plugin\n provides many convenient features:\n\n\n\n\nIt collects all the jars on the classpath and builds a single, runnable \"\u00fcber-jar\", which makes it more convenient to execute and transport your service.\n\n\nIt searches for the \npublic static void main()\n method to flag as a runnable class.\n\n\nIt provides a built-in dependency resolver that sets the version number to match \nSpring Boot dependencies\n. You can override any version you wish, but it will default to Boot\u2019s chosen set of versions.\n\n\n\n\nDefine a simple entity with content\n\n\nIn this example, you store Document objects, annotated as a Mongo entity with Content.\n\n\nsrc/main/java/docs/SpringDocument.java\n\n\npackage docs;\n\nimport org.springframework.content.annotations.Content;\nimport org.springframework.content.annotations.ContentId;\nimport org.springframework.content.annotations.ContentLength;\nimport org.springframework.data.annotation.Id;\nimport org.springframework.data.mongodb.core.mapping.Document;\n\n@Document\npublic class SpringDocument {\n\n    @Id\n    private String id;\n\n    private String title;\n    private List\nString\n keywords;\n\n    @Content\n    private ContentMetadata content;\n\n    ... getters and setters ...\n\n    public static class ContentMetadata {\n\n        public ContentMetadata() {}\n\n        @ContentId\n        private String id;\n\n        @ContentLength\n        private long length;\n\n        @MimeType\n        private String mimeType;\n\n        .. getters and setters ...\n\n    }\n}\n\n\n\nHere you have a standard Spring Data entity bean class \nSpringDocument\n class with several attributes, \nid\n, \ntitle\n, \nkeywords\n.\n\n\n\n\nNote:\n For more information on Spring Data annotations see the relevant \nSpring Data\n documentation.\n\n\n\n\nIn addition this entity bean also has the \ncontent\n attribute annotated with the Spring Content annotation \n@Content\n, indicating that instances of \nContentMetadata\n are content entities.  These entities will be mapped to Mongo's GridFS.  \n\n\nContentMetadata\n has three attributes, \nid\n, \nlength\n and \nmimeType\n.  The \nid\n attribute is annotated with \n@ContentId\n so that Spring Content will recognize it as the content entity's ID.  \n\n\nThe \nlength\n attribute is annotated with \n@ContentLength\n so that Spring Content will recognize it as the content entity's content length.  \n\n\nFinally, the \nmimeType\n attribute is annotated with \n@MimeType\n so that Spring Content REST will recognize it as the content entity's mime type.\n\n\nAll of these annotated attributes will be managed by Spring Content. \n\n\nCreate a Spring Data Repository\n\n\nSo that we can perform simple CRUD operations, over a hypermedia-based API, create a simple repository for the \nSpringDocument\n class annotated with as a \n@RepositoryRestResource\n.\n\n\nsrc/main/java/docs/SpringDocumentRepository.java\n\n\npackage docs;\n\nimport org.springframework.data.repository.CrudRepository;\nimport org.springframework.data.rest.core.annotation.RepositoryRestResource;\n\n@RepositoryRestResource(path=\"/docs\", collectionResourceRel=\"docs\")\npublic interface SpringDocumentRepository extends CrudRepository\nSpringDocument, String\n {\n\n}\n\n\n\nAdd a Spring Content Repository\n\n\nJust like Spring Data focuses on storing data in a database, Spring Content focuses on storing content in various stores, in this case in Mongo GridFS store.  It's most compelling feature is the ability to create content store implementations automatically, at runtime, from a content store interface.\n\n\nTo see how this works, create a content store interface that works with SpringDocument's \nContentMetadata\n entity:\n\n\nsrc/main/java/docs/ContentMetadataContentStore.java\n\n\npackage docs;\n\nimport org.springframework.content.common.repository.ContentStore;\n\nimport docs.SpringDocument.ContentMetadata;\nimport internal.org.springframework.content.rest.annotations.ContentStoreRestResource;\n\n@ContentRepositoryRestResource\npublic interface ContentMetadataContentStore extends ContentStore\nContentMetadata, String\n {\n}\n\n\n\nContentMetadataContentStore\n extends the \nContentStore\n interface.  The type of the content entity and the type of the content entity's ID, \nContentMetadata\n and \nString\n respectively, are specified in the generic parameters on \nContentStore\n.  By extending \nContentStore\n, \nContentMetadataContentStore\n inherits several methods for working with persisted content.\n\n\nIn a java application, you would expect to write an implementation for the \nContentMetadaDataContentStore\n class.  But what makes Spring Content so powerful is that you don't have to do this.  Spring Content will create an implementation on the fly when you run the application.\n\n\nLikewise, in a web-based application you would also expect to implement HTTP handlers allowing you to PUT and GET content over HTTP.  With Spring Content REST these are also implemented for you when you add the \nContentStoreRestResource\n annotation to your content store.          \n\n\nLet's wire this up and see what it looks like!\n\n\nCreate an application class\n\n\nSpring Content integrates seamlessly into Spring Boot, therefore you create the standard Application class. \n\n\nsrc/main/java/docs/Application.java\n\n\npackage docs;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class ContentApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(ContentApplication.class);\n    }\n}\n\n\n\nBuild an executable JAR\n\n\nYou can build a single executable JAR file that contains all the necessary dependencies, classes and resources.  This makes it easy to ship, version and deploy.\n\n\nIf you are using Maven, you can run the application using \nmvn spring-boot:run\n. Or you can build the JAR file with \nmvn clean package\n and run the JAR by typing:\n\n\njava -jar target/spring-gs-accessing-content-mongo-0.1.0.jar\n\n\n\n\n\nNote:\n The procedure above will create a runnable JAR. You can also opt to \nbuild a classic WAR file\n instead.\n\n\n\n\nHandle Content\n\n\nFirst create an instance of a \nSpringDocument\n.  Using curl, issue the following command:\n\n\ncurl -XPOST -H 'Content-Type:application/json' -d '{\"title\":\"test doc\",\"keywords\":[\"one\",\"two\"]}' http://localhost:8080/docs\n\n\n\nCheck that this \nSpringDocument\n was created by issing the following command:\n\n\ncurl http://localhost:8080/docs\n\n\n\nand this should respond with:\n\n\n{\n  \"_embedded\" : {\n    \"docs\" : [ {\n      \"title\" : \"test doc\",\n      \"keywords\" : [ \"one\", \"two\" ],\n      \"content\" : null,\n      \"_links\" : {\n        \"self\" : {\n          \"href\" : \"http://localhost:8080/docs/5636224fa82677aa529322b6\"\n        }\n      }\n    } ]\n  }\n}\n\n\n\nwhich shows us there is one document that may be fetched with a \nGET\n request to \nhttp://localhost:8080/docs/5636224fa82677aa529322b6\n\n\n\n\nNote:\n you're IDs will obviously be different, adjust as appropriate\n\n\n\n\nNotice, that the \ncontent\n attribute is null.  That is because we haven't added any content yet so let's add some, issue the following command:\n\n\ncurl -XPOST -F file=@/tmp/test.txt http://localhost:8080/docs/5636224fa82677aa529322b6/content\n\n\n\n\n\nNote:\n In our example /tmp/test.txt contains the simple plain text \nHello Spring Content World!\n but this could be any binary content\n\n\n\n\nNow, re-query the original \nSpringDocument\n again:-\n\n\ncurl http://localhost:8080/docs/5636224fa82677aa529322b6\n\n\n\nThis time it should respond with:\n\n\n{\n  \"title\" : \"test doc\",\n  \"keywords\" : [ \"one\", \"two\" ],\n  \"content\" : {\n    \"length\" : 28,\n    \"mimeType\" : \"text/plain\"\n  },\n  \"_links\" : {\n    \"self\" : {\n      \"href\" : \"http://localhost:8080/docs/5636224fa82677aa529322b6\"\n    },\n    \"content\" : {\n      \"href\" : \"http://localhost:8080/docs/5636224fa82677aa529322b6/content/64bf2339-c8e5-44f1-b960-aeb9ea8e4a7e\"\n    }\n  }\n}\n\n\n\nWe see the \ncontent\n attribute now contains useful information about the document's content, namely \nlength\n and \nmimeType\n.  These were set automatically by Spring Content.\n\n\nSimilarly, \n_links\n also now contains a linkrel for \ncontent\n allowing clients to navigate from this \nSpringDocument\n resource to it's content.  Let's do that now, issue the command:\n\n\nhttp://localhost:8080/docs/5636224fa82677aa529322b6/content/64bf2339-c8e5-44f1-b960-aeb9ea8e4a7e\n\n\n\nwhich responds:\n\n\nHello Spring Content World!\n\n\n\nSummary\n\n\nCongratulations!  You've written a simple application that uses Spring Content and Spring Content REST to save objects with content to a database and to fetch them again using a hypermedia-based REST API - all without writing a single concrete implementation class.", 
            "title": "Getting Started with REST"
        }, 
        {
            "location": "/spring-content-rest-docs/#getting-started-with-spring-content-rest", 
            "text": "This guide walks you through building an application that uses Spring Content to store and retrieve  content in a database.", 
            "title": "Getting Started with Spring Content REST"
        }, 
        {
            "location": "/spring-content-rest-docs/#what-youll-build", 
            "text": "You'll build an application that stores Document POJOs in a Mongo database.", 
            "title": "What you'll build"
        }, 
        {
            "location": "/spring-content-rest-docs/#what-youll-need", 
            "text": "About 30 minutes  A favorite text editor or IDE  JDK 1.8 or later  Maven 3.0+  MongoDB 3.0.7  You can also import the code from this guide as well as view the web page directly into Spring Tool Suite (STS) and work your way through it from there.", 
            "title": "What you'll need"
        }, 
        {
            "location": "/spring-content-rest-docs/#how-to-complete-this-guide", 
            "text": "Like most Spring Getting Started guides, you can start form scratch and complete each step, or you can bypass basic setup steps that are already familiar to you. Either way, you end up with working code.  To start from scratch, move on to Build with Maven.  To skip the basics, do the following:   Download and unzip the source repository for this guide, or clone it using Git:  git clone https://github.com/EMC-Dojo/spring-gs-content.git  cd into spring-gs-content/spring-gs-content-mongorest/initial  Jump ahead to  Define a simple entity .\nWhen you\u2019re finished, you can check your results against the code in  spring-gs-content/spring-gs-content-mongorest/complete .", 
            "title": "How to complete this guide"
        }, 
        {
            "location": "/spring-content-rest-docs/#build-with-maven", 
            "text": "First you set up a basic build script. You can use any build system you like when building apps with Spring, but the code you need to work with  Maven  is included here. If you\u2019re not familiar with Maven, refer to  Building Java Projects with Maven .", 
            "title": "Build with Maven"
        }, 
        {
            "location": "/spring-content-rest-docs/#create-a-directory-structure", 
            "text": "In a project directory of your choosing, create the following subdirectory structure; for example, with  mkdir -p src/main/java/hello  on *nix systems:  \u221f src\n   \u221f main\n       \u221f java\n           \u221f docs  pom.xml  ?xml version=\"1.0\" encoding=\"UTF-8\"?  project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" \n     modelVersion 4.0.0 /modelVersion \n\n     groupId org.springframework.content.gs /groupId \n     artifactId gs-accessing-content-jpa /artifactId \n     version 0.1.0 /version \n\n     parent \n         groupId org.springframework.boot /groupId \n         artifactId spring-boot-starter-parent /artifactId \n         version 1.3.2.RELEASE /version \n     /parent \n\n     dependencies \n         dependency \n             groupId org.springframework.boot /groupId \n             artifactId spring-boot-starter-data-mongodb /artifactId \n         /dependency \n         dependency \n             groupId org.springframework.boot /groupId \n             artifactId spring-boot-starter-data-rest /artifactId \n         /dependency \n         dependency \n             groupId org.springframework.boot /groupId \n             artifactId spring-boot-starter-web /artifactId \n         /dependency \n         dependency \n             groupId org.springframework.boot /groupId \n             artifactId spring-content-mongo-boot-starter /artifactId \n             version 1.3.2.RELEASE /version \n         /dependency \n         dependency \n             groupId org.springframework.boot /groupId \n             artifactId spring-content-rest-boot-starter /artifactId \n             version 1.3.2.RELEASE /version \n         /dependency \n     /dependencies \n\n     properties \n         java.version 1.8 /java.version \n     /properties \n\n     build \n         plugins \n             plugin \n                 groupId org.springframework.boot /groupId \n                 artifactId spring-boot-maven-plugin /artifactId \n             /plugin \n         /plugins \n     /build  /project   The  Spring Boot Maven plugin  provides many convenient features:   It collects all the jars on the classpath and builds a single, runnable \"\u00fcber-jar\", which makes it more convenient to execute and transport your service.  It searches for the  public static void main()  method to flag as a runnable class.  It provides a built-in dependency resolver that sets the version number to match  Spring Boot dependencies . You can override any version you wish, but it will default to Boot\u2019s chosen set of versions.", 
            "title": "Create a directory structure"
        }, 
        {
            "location": "/spring-content-rest-docs/#define-a-simple-entity-with-content", 
            "text": "In this example, you store Document objects, annotated as a Mongo entity with Content.  src/main/java/docs/SpringDocument.java  package docs;\n\nimport org.springframework.content.annotations.Content;\nimport org.springframework.content.annotations.ContentId;\nimport org.springframework.content.annotations.ContentLength;\nimport org.springframework.data.annotation.Id;\nimport org.springframework.data.mongodb.core.mapping.Document;\n\n@Document\npublic class SpringDocument {\n\n    @Id\n    private String id;\n\n    private String title;\n    private List String  keywords;\n\n    @Content\n    private ContentMetadata content;\n\n    ... getters and setters ...\n\n    public static class ContentMetadata {\n\n        public ContentMetadata() {}\n\n        @ContentId\n        private String id;\n\n        @ContentLength\n        private long length;\n\n        @MimeType\n        private String mimeType;\n\n        .. getters and setters ...\n\n    }\n}  Here you have a standard Spring Data entity bean class  SpringDocument  class with several attributes,  id ,  title ,  keywords .   Note:  For more information on Spring Data annotations see the relevant  Spring Data  documentation.   In addition this entity bean also has the  content  attribute annotated with the Spring Content annotation  @Content , indicating that instances of  ContentMetadata  are content entities.  These entities will be mapped to Mongo's GridFS.    ContentMetadata  has three attributes,  id ,  length  and  mimeType .  The  id  attribute is annotated with  @ContentId  so that Spring Content will recognize it as the content entity's ID.    The  length  attribute is annotated with  @ContentLength  so that Spring Content will recognize it as the content entity's content length.    Finally, the  mimeType  attribute is annotated with  @MimeType  so that Spring Content REST will recognize it as the content entity's mime type.  All of these annotated attributes will be managed by Spring Content.", 
            "title": "Define a simple entity with content"
        }, 
        {
            "location": "/spring-content-rest-docs/#create-a-spring-data-repository", 
            "text": "So that we can perform simple CRUD operations, over a hypermedia-based API, create a simple repository for the  SpringDocument  class annotated with as a  @RepositoryRestResource .  src/main/java/docs/SpringDocumentRepository.java  package docs;\n\nimport org.springframework.data.repository.CrudRepository;\nimport org.springframework.data.rest.core.annotation.RepositoryRestResource;\n\n@RepositoryRestResource(path=\"/docs\", collectionResourceRel=\"docs\")\npublic interface SpringDocumentRepository extends CrudRepository SpringDocument, String  {\n\n}", 
            "title": "Create a Spring Data Repository"
        }, 
        {
            "location": "/spring-content-rest-docs/#add-a-spring-content-repository", 
            "text": "Just like Spring Data focuses on storing data in a database, Spring Content focuses on storing content in various stores, in this case in Mongo GridFS store.  It's most compelling feature is the ability to create content store implementations automatically, at runtime, from a content store interface.  To see how this works, create a content store interface that works with SpringDocument's  ContentMetadata  entity:  src/main/java/docs/ContentMetadataContentStore.java  package docs;\n\nimport org.springframework.content.common.repository.ContentStore;\n\nimport docs.SpringDocument.ContentMetadata;\nimport internal.org.springframework.content.rest.annotations.ContentStoreRestResource;\n\n@ContentRepositoryRestResource\npublic interface ContentMetadataContentStore extends ContentStore ContentMetadata, String  {\n}  ContentMetadataContentStore  extends the  ContentStore  interface.  The type of the content entity and the type of the content entity's ID,  ContentMetadata  and  String  respectively, are specified in the generic parameters on  ContentStore .  By extending  ContentStore ,  ContentMetadataContentStore  inherits several methods for working with persisted content.  In a java application, you would expect to write an implementation for the  ContentMetadaDataContentStore  class.  But what makes Spring Content so powerful is that you don't have to do this.  Spring Content will create an implementation on the fly when you run the application.  Likewise, in a web-based application you would also expect to implement HTTP handlers allowing you to PUT and GET content over HTTP.  With Spring Content REST these are also implemented for you when you add the  ContentStoreRestResource  annotation to your content store.            Let's wire this up and see what it looks like!", 
            "title": "Add a Spring Content Repository"
        }, 
        {
            "location": "/spring-content-rest-docs/#create-an-application-class", 
            "text": "Spring Content integrates seamlessly into Spring Boot, therefore you create the standard Application class.   src/main/java/docs/Application.java  package docs;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class ContentApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(ContentApplication.class);\n    }\n}", 
            "title": "Create an application class"
        }, 
        {
            "location": "/spring-content-rest-docs/#build-an-executable-jar", 
            "text": "You can build a single executable JAR file that contains all the necessary dependencies, classes and resources.  This makes it easy to ship, version and deploy.  If you are using Maven, you can run the application using  mvn spring-boot:run . Or you can build the JAR file with  mvn clean package  and run the JAR by typing:  java -jar target/spring-gs-accessing-content-mongo-0.1.0.jar   Note:  The procedure above will create a runnable JAR. You can also opt to  build a classic WAR file  instead.", 
            "title": "Build an executable JAR"
        }, 
        {
            "location": "/spring-content-rest-docs/#handle-content", 
            "text": "First create an instance of a  SpringDocument .  Using curl, issue the following command:  curl -XPOST -H 'Content-Type:application/json' -d '{\"title\":\"test doc\",\"keywords\":[\"one\",\"two\"]}' http://localhost:8080/docs  Check that this  SpringDocument  was created by issing the following command:  curl http://localhost:8080/docs  and this should respond with:  {\n  \"_embedded\" : {\n    \"docs\" : [ {\n      \"title\" : \"test doc\",\n      \"keywords\" : [ \"one\", \"two\" ],\n      \"content\" : null,\n      \"_links\" : {\n        \"self\" : {\n          \"href\" : \"http://localhost:8080/docs/5636224fa82677aa529322b6\"\n        }\n      }\n    } ]\n  }\n}  which shows us there is one document that may be fetched with a  GET  request to  http://localhost:8080/docs/5636224fa82677aa529322b6   Note:  you're IDs will obviously be different, adjust as appropriate   Notice, that the  content  attribute is null.  That is because we haven't added any content yet so let's add some, issue the following command:  curl -XPOST -F file=@/tmp/test.txt http://localhost:8080/docs/5636224fa82677aa529322b6/content   Note:  In our example /tmp/test.txt contains the simple plain text  Hello Spring Content World!  but this could be any binary content   Now, re-query the original  SpringDocument  again:-  curl http://localhost:8080/docs/5636224fa82677aa529322b6  This time it should respond with:  {\n  \"title\" : \"test doc\",\n  \"keywords\" : [ \"one\", \"two\" ],\n  \"content\" : {\n    \"length\" : 28,\n    \"mimeType\" : \"text/plain\"\n  },\n  \"_links\" : {\n    \"self\" : {\n      \"href\" : \"http://localhost:8080/docs/5636224fa82677aa529322b6\"\n    },\n    \"content\" : {\n      \"href\" : \"http://localhost:8080/docs/5636224fa82677aa529322b6/content/64bf2339-c8e5-44f1-b960-aeb9ea8e4a7e\"\n    }\n  }\n}  We see the  content  attribute now contains useful information about the document's content, namely  length  and  mimeType .  These were set automatically by Spring Content.  Similarly,  _links  also now contains a linkrel for  content  allowing clients to navigate from this  SpringDocument  resource to it's content.  Let's do that now, issue the command:  http://localhost:8080/docs/5636224fa82677aa529322b6/content/64bf2339-c8e5-44f1-b960-aeb9ea8e4a7e  which responds:  Hello Spring Content World!", 
            "title": "Handle Content"
        }, 
        {
            "location": "/spring-content-rest-docs/#summary", 
            "text": "Congratulations!  You've written a simple application that uses Spring Content and Spring Content REST to save objects with content to a database and to fetch them again using a hypermedia-based REST API - all without writing a single concrete implementation class.", 
            "title": "Summary"
        }
    ]
}