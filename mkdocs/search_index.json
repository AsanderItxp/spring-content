{
    "docs": [
        {
            "location": "/", 
            "text": "Spring-Content\n\n\nExtensions for Spring-Data that add primitives for handling BLOBs, in the same Developer-friendly way that you handle your structured data.\n\n\nSpring Content provides modules for JPA, MongoDB, S3 and the Filesystem.\n\n\nQuick Start\n\n\nFor a quick taste, look at the following domain object:\n\n\n@Entity\n@Content\npublic class SopDocument {\n\n    private @Id @GeneratedValue Long id;\n    private String title;\n    private String[] authors, keywords;\n    private @ContentId String contentId\n\n    private SopDocument() {}\n    public SopDocument(String title, String[] authors, String[] keywords)   {\n        this.title = title;\n        this.authors = authors;\n        this.keywords = keywords;\n    }\n}\n\n\n\n\nThis defines a simple JPA entity with a few structured data fields; title, authors and keywords and one BLOB field denoted by the @ContentId field.  The structured data fields are handled in the usual way through a \nCrudRepository\nSopDocument,String\n interface.  The BLOB field is handled separately with a ContentRepository interface:-\n\n\npublic interface ContentRepository extends ContentRepository\nSopDocument, String\n {\n}\n\n\n\n\nThis interface extends Spring Content\u2019s ContentRepository and defines the type (SopDocument) and the id type (String).  Put this code inside a Spring Boot application with spring-boot-starter-data-jpa and spring-content-jpa-boot-starter like this:\n\n\n@SpringBootApplication\npublic class MyApp {\n\n    public static void main(String[] args) {\n        SpringApplication.run(MyApp.class, args);\n    }\n}\n\n\n\n\nLaunch your app and Spring Content (having been autoconfigured by Boot) will automatically craft a concrete set of operations for handling content for this Entity:\n\n\n\n\nsetContent(S property, InputStream content)\n\n\nunsetContent(S property)\n\n\nInputStream getContent(S property)", 
            "title": "Home"
        }, 
        {
            "location": "/#spring-content", 
            "text": "Extensions for Spring-Data that add primitives for handling BLOBs, in the same Developer-friendly way that you handle your structured data.  Spring Content provides modules for JPA, MongoDB, S3 and the Filesystem.", 
            "title": "Spring-Content"
        }, 
        {
            "location": "/#quick-start", 
            "text": "For a quick taste, look at the following domain object:  @Entity\n@Content\npublic class SopDocument {\n\n    private @Id @GeneratedValue Long id;\n    private String title;\n    private String[] authors, keywords;\n    private @ContentId String contentId\n\n    private SopDocument() {}\n    public SopDocument(String title, String[] authors, String[] keywords)   {\n        this.title = title;\n        this.authors = authors;\n        this.keywords = keywords;\n    }\n}  This defines a simple JPA entity with a few structured data fields; title, authors and keywords and one BLOB field denoted by the @ContentId field.  The structured data fields are handled in the usual way through a  CrudRepository SopDocument,String  interface.  The BLOB field is handled separately with a ContentRepository interface:-  public interface ContentRepository extends ContentRepository SopDocument, String  {\n}  This interface extends Spring Content\u2019s ContentRepository and defines the type (SopDocument) and the id type (String).  Put this code inside a Spring Boot application with spring-boot-starter-data-jpa and spring-content-jpa-boot-starter like this:  @SpringBootApplication\npublic class MyApp {\n\n    public static void main(String[] args) {\n        SpringApplication.run(MyApp.class, args);\n    }\n}  Launch your app and Spring Content (having been autoconfigured by Boot) will automatically craft a concrete set of operations for handling content for this Entity:   setContent(S property, InputStream content)  unsetContent(S property)  InputStream getContent(S property)", 
            "title": "Quick Start"
        }, 
        {
            "location": "/spring-content-webdav/", 
            "text": "Getting Started with Spring Content\n\n\n// TODO", 
            "title": "Getting Started with Spring Content"
        }, 
        {
            "location": "/spring-content-webdav/#getting-started-with-spring-content", 
            "text": "// TODO", 
            "title": "Getting Started with Spring Content"
        }, 
        {
            "location": "/spring-content-rest/", 
            "text": "Getting Started with Spring Content REST\n\n\nThis guide walks you through building an application that uses Spring Content to store and retrieve  content in a database.\n\n\nWhat you'll build\n\n\nYou'll build an application that stores Document POJOs in a Mongo database.\n\n\nWhat you'll need\n\n\n\n\nAbout 30 minutes\n\n\nA favorite text editor or IDE\n\n\nJDK 1.8 or later\n\n\nMaven 3.0+\n\n\nMongoDB 3.0.7\n\n\nYou can also import the code from this guide as well as view the web page directly into Spring Tool Suite (STS) and work your way through it from there.\n\n\n\n\nHow to complete this guide\n\n\nLike most Spring Getting Started guides, you can start form scratch and complete each step, or you can bypass basic setup steps that are already familiar to you. Either way, you end up with working code.\n\n\nTo start from scratch, move on to Build with Maven.\n\n\nTo skip the basics, do the following:\n\n\n\n\nDownload and unzip the source repository for this guide, or clone it using Git: \ngit clone https://github.com/EMC-Dojo/spring-gs-content.git\n\n\ncd into spring-gs-content/spring-gs-content-mongorest/initial\n\n\nJump ahead to \nDefine a simple entity\n.\nWhen you\u2019re finished, you can check your results against the code in \nspring-gs-content/spring-gs-content-mongorest/complete\n.\n\n\n\n\nBuild with Maven\n\n\nFirst you set up a basic build script. You can use any build system you like when building apps with Spring, but the code you need to work with \nMaven\n is included here. If you\u2019re not familiar with Maven, refer to \nBuilding Java Projects with Maven\n. \n\n\nCreate a directory structure\n\n\nIn a project directory of your choosing, create the following subdirectory structure; for example, with \nmkdir -p src/main/java/hello\n on *nix systems:\n\n\n\u221f src\n   \u221f main\n       \u221f java\n           \u221f docs\n\n\n\n\npom.xml\n\n\n?xml version=\"1.0\" encoding=\"UTF-8\"?\n\n\nproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\n\n    \nmodelVersion\n4.0.0\n/modelVersion\n\n\n    \ngroupId\norg.springframework.content.gs\n/groupId\n\n    \nartifactId\ngs-accessing-content-jpa\n/artifactId\n\n    \nversion\n0.1.0\n/version\n\n\n    \nparent\n\n        \ngroupId\norg.springframework.boot\n/groupId\n\n        \nartifactId\nspring-boot-starter-parent\n/artifactId\n\n        \nversion\n1.3.2.RELEASE\n/version\n\n    \n/parent\n\n\n    \ndependencies\n\n        \ndependency\n\n            \ngroupId\norg.springframework.boot\n/groupId\n\n            \nartifactId\nspring-boot-starter-data-mongodb\n/artifactId\n\n        \n/dependency\n\n        \ndependency\n\n            \ngroupId\norg.springframework.boot\n/groupId\n\n            \nartifactId\nspring-boot-starter-data-rest\n/artifactId\n\n        \n/dependency\n\n        \ndependency\n\n            \ngroupId\norg.springframework.boot\n/groupId\n\n            \nartifactId\nspring-boot-starter-web\n/artifactId\n\n        \n/dependency\n\n        \ndependency\n\n            \ngroupId\norg.springframework.boot\n/groupId\n\n            \nartifactId\nspring-content-mongo-boot-starter\n/artifactId\n\n            \nversion\n1.3.2.RELEASE\n/version\n\n        \n/dependency\n\n        \ndependency\n\n            \ngroupId\norg.springframework.boot\n/groupId\n\n            \nartifactId\nspring-content-rest-boot-starter\n/artifactId\n\n            \nversion\n1.3.2.RELEASE\n/version\n\n        \n/dependency\n\n    \n/dependencies\n\n\n    \nproperties\n\n        \njava.version\n1.8\n/java.version\n\n    \n/properties\n\n\n    \nbuild\n\n        \nplugins\n\n            \nplugin\n\n                \ngroupId\norg.springframework.boot\n/groupId\n\n                \nartifactId\nspring-boot-maven-plugin\n/artifactId\n\n            \n/plugin\n\n        \n/plugins\n\n    \n/build\n\n\n/project\n\n\n\n\nThe \nSpring Boot Maven plugin\n provides many convenient features:\n\n\n\n\nIt collects all the jars on the classpath and builds a single, runnable \"\u00fcber-jar\", which makes it more convenient to execute and transport your service.\n\n\nIt searches for the \npublic static void main()\n method to flag as a runnable class.\n\n\nIt provides a built-in dependency resolver that sets the version number to match \nSpring Boot dependencies\n. You can override any version you wish, but it will default to Boot\u2019s chosen set of versions.\n\n\n\n\nDefine a simple entity with content\n\n\nIn this example, you store Document objects, annotated as a Mongo entity with Content.\n\n\nsrc/main/java/docs/SpringDocument.java\n\n\npackage docs;\n\nimport org.springframework.content.annotations.Content;\nimport org.springframework.content.annotations.ContentId;\nimport org.springframework.content.annotations.ContentLength;\nimport org.springframework.data.annotation.Id;\nimport org.springframework.data.mongodb.core.mapping.Document;\n\n@Document\npublic class SpringDocument {\n\n    @Id\n    private String id;\n\n    private String title;\n    private List\nString\n keywords;\n\n    @Content\n    private ContentMetadata content;\n\n    ... getters and setters ...\n\n    public static class ContentMetadata {\n\n        public ContentMetadata() {}\n\n        @ContentId\n        private String id;\n\n        @ContentLength\n        private long length;\n\n        @MimeType\n        private String mimeType;\n\n        .. getters and setters ...\n\n    }\n}\n\n\n\nHere you have a standard Spring Data entity bean class \nSpringDocument\n class with several attributes, \nid\n, \ntitle\n, \nkeywords\n.\n\n\n\n\nNote:\n For more information on Spring Data annotations see the relevant \nSpring Data\n documentation.\n\n\n\n\nIn addition this entity bean also has the \ncontent\n attribute annotated with the Spring Content annotation \n@Content\n, indicating that instances of \nContentMetadata\n are content entities.  These entities will be mapped to Mongo's GridFS.  \n\n\nContentMetadata\n has three attributes, \nid\n, \nlength\n and \nmimeType\n.  The \nid\n attribute is annotated with \n@ContentId\n so that Spring Content will recognize it as the content entity's ID.  \n\n\nThe \nlength\n attribute is annotated with \n@ContentLength\n so that Spring Content will recognize it as the content entity's content length.  \n\n\nFinally, the \nmimeType\n attribute is annotated with \n@MimeType\n so that Spring Content REST will recognize it as the content entity's mime type.\n\n\nAll of these annotated attributes will be managed by Spring Content. \n\n\nCreate a Spring Data Repository\n\n\nSo that we can perform simple CRUD operations, over a hypermedia-based API, create a simple repository for the \nSpringDocument\n class annotated with as a \n@RepositoryRestResource\n.\n\n\nsrc/main/java/docs/SpringDocumentRepository.java\n\n\npackage docs;\n\nimport org.springframework.data.repository.CrudRepository;\nimport org.springframework.data.rest.core.annotation.RepositoryRestResource;\n\n@RepositoryRestResource(path=\"/docs\", collectionResourceRel=\"docs\")\npublic interface SpringDocumentRepository extends CrudRepository\nSpringDocument, String\n {\n\n}\n\n\n\nAdd a Spring Content Repository\n\n\nJust like Spring Data focuses on storing data in a database, Spring Content focuses on storing content in various stores, in this case in Mongo GridFS store.  It's most compelling feature is the ability to create content store implementations automatically, at runtime, from a content store interface.\n\n\nTo see how this works, create a content store interface that works with SpringDocument's \nContentMetadata\n entity:\n\n\nsrc/main/java/docs/ContentMetadataContentStore.java\n\n\npackage docs;\n\nimport org.springframework.content.common.repository.ContentStore;\n\nimport docs.SpringDocument.ContentMetadata;\nimport internal.org.springframework.content.rest.annotations.ContentStoreRestResource;\n\n@ContentRepositoryRestResource\npublic interface ContentMetadataContentStore extends ContentStore\nContentMetadata, String\n {\n}\n\n\n\nContentMetadataContentStore\n extends the \nContentStore\n interface.  The type of the content entity and the type of the content entity's ID, \nContentMetadata\n and \nString\n respectively, are specified in the generic parameters on \nContentStore\n.  By extending \nContentStore\n, \nContentMetadataContentStore\n inherits several methods for working with persisted content.\n\n\nIn a java application, you would expect to write an implementation for the \nContentMetadaDataContentStore\n class.  But what makes Spring Content so powerful is that you don't have to do this.  Spring Content will create an implementation on the fly when you run the application.\n\n\nLikewise, in a web-based application you would also expect to implement HTTP handlers allowing you to PUT and GET content over HTTP.  With Spring Content REST these are also implemented for you when you add the \nContentStoreRestResource\n annotation to your content store.          \n\n\nLet's wire this up and see what it looks like!\n\n\nCreate an application class\n\n\nSpring Content integrates seamlessly into Spring Boot, therefore you create the standard Application class. \n\n\nsrc/main/java/docs/Application.java\n\n\npackage docs;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class ContentApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(ContentApplication.class);\n    }\n}\n\n\n\nBuild an executable JAR\n\n\nYou can build a single executable JAR file that contains all the necessary dependencies, classes and resources.  This makes it easy to ship, version and deploy.\n\n\nIf you are using Maven, you can run the application using \nmvn spring-boot:run\n. Or you can build the JAR file with \nmvn clean package\n and run the JAR by typing:\n\n\njava -jar target/spring-gs-accessing-content-mongo-0.1.0.jar\n\n\n\n\n\nNote:\n The procedure above will create a runnable JAR. You can also opt to \nbuild a classic WAR file\n instead.\n\n\n\n\nHandle Content\n\n\nFirst create an instance of a \nSpringDocument\n.  Using curl, issue the following command:\n\n\ncurl -XPOST -H 'Content-Type:application/json' -d '{\"title\":\"test doc\",\"keywords\":[\"one\",\"two\"]}' http://localhost:8080/docs\n\n\n\nCheck that this \nSpringDocument\n was created by issing the following command:\n\n\ncurl http://localhost:8080/docs\n\n\n\nand this should respond with:\n\n\n{\n  \"_embedded\" : {\n    \"docs\" : [ {\n      \"title\" : \"test doc\",\n      \"keywords\" : [ \"one\", \"two\" ],\n      \"content\" : null,\n      \"_links\" : {\n        \"self\" : {\n          \"href\" : \"http://localhost:8080/docs/5636224fa82677aa529322b6\"\n        }\n      }\n    } ]\n  }\n}\n\n\n\nwhich shows us there is one document that may be fetched with a \nGET\n request to \nhttp://localhost:8080/docs/5636224fa82677aa529322b6\n\n\n\n\nNote:\n you're IDs will obviously be different, adjust as appropriate\n\n\n\n\nNotice, that the \ncontent\n attribute is null.  That is because we haven't added any content yet so let's add some, issue the following command:\n\n\ncurl -XPOST -F file=@/tmp/test.txt http://localhost:8080/docs/5636224fa82677aa529322b6/content\n\n\n\n\n\nNote:\n In our example /tmp/test.txt contains the simple plain text \nHello Spring Content World!\n but this could be any binary content\n\n\n\n\nNow, re-query the original \nSpringDocument\n again:-\n\n\ncurl http://localhost:8080/docs/5636224fa82677aa529322b6\n\n\n\nThis time it should respond with:\n\n\n{\n  \"title\" : \"test doc\",\n  \"keywords\" : [ \"one\", \"two\" ],\n  \"content\" : {\n    \"length\" : 28,\n    \"mimeType\" : \"text/plain\"\n  },\n  \"_links\" : {\n    \"self\" : {\n      \"href\" : \"http://localhost:8080/docs/5636224fa82677aa529322b6\"\n    },\n    \"content\" : {\n      \"href\" : \"http://localhost:8080/docs/5636224fa82677aa529322b6/content/64bf2339-c8e5-44f1-b960-aeb9ea8e4a7e\"\n    }\n  }\n}\n\n\n\nWe see the \ncontent\n attribute now contains useful information about the document's content, namely \nlength\n and \nmimeType\n.  These were set automatically by Spring Content.\n\n\nSimilarly, \n_links\n also now contains a linkrel for \ncontent\n allowing clients to navigate from this \nSpringDocument\n resource to it's content.  Let's do that now, issue the command:\n\n\nhttp://localhost:8080/docs/5636224fa82677aa529322b6/content/64bf2339-c8e5-44f1-b960-aeb9ea8e4a7e\n\n\n\nwhich responds:\n\n\nHello Spring Content World!\n\n\n\nSummary\n\n\nCongratulations!  You've written a simple application that uses Spring Content and Spring Content REST to save objects with content to a database and to fetch them again using a hypermedia-based REST API - all without writing a single concrete implementation class.", 
            "title": "Getting Started with REST"
        }, 
        {
            "location": "/spring-content-rest/#getting-started-with-spring-content-rest", 
            "text": "This guide walks you through building an application that uses Spring Content to store and retrieve  content in a database.", 
            "title": "Getting Started with Spring Content REST"
        }, 
        {
            "location": "/spring-content-rest/#what-youll-build", 
            "text": "You'll build an application that stores Document POJOs in a Mongo database.", 
            "title": "What you'll build"
        }, 
        {
            "location": "/spring-content-rest/#what-youll-need", 
            "text": "About 30 minutes  A favorite text editor or IDE  JDK 1.8 or later  Maven 3.0+  MongoDB 3.0.7  You can also import the code from this guide as well as view the web page directly into Spring Tool Suite (STS) and work your way through it from there.", 
            "title": "What you'll need"
        }, 
        {
            "location": "/spring-content-rest/#how-to-complete-this-guide", 
            "text": "Like most Spring Getting Started guides, you can start form scratch and complete each step, or you can bypass basic setup steps that are already familiar to you. Either way, you end up with working code.  To start from scratch, move on to Build with Maven.  To skip the basics, do the following:   Download and unzip the source repository for this guide, or clone it using Git:  git clone https://github.com/EMC-Dojo/spring-gs-content.git  cd into spring-gs-content/spring-gs-content-mongorest/initial  Jump ahead to  Define a simple entity .\nWhen you\u2019re finished, you can check your results against the code in  spring-gs-content/spring-gs-content-mongorest/complete .", 
            "title": "How to complete this guide"
        }, 
        {
            "location": "/spring-content-rest/#build-with-maven", 
            "text": "First you set up a basic build script. You can use any build system you like when building apps with Spring, but the code you need to work with  Maven  is included here. If you\u2019re not familiar with Maven, refer to  Building Java Projects with Maven .", 
            "title": "Build with Maven"
        }, 
        {
            "location": "/spring-content-rest/#create-a-directory-structure", 
            "text": "In a project directory of your choosing, create the following subdirectory structure; for example, with  mkdir -p src/main/java/hello  on *nix systems:  \u221f src\n   \u221f main\n       \u221f java\n           \u221f docs  pom.xml  ?xml version=\"1.0\" encoding=\"UTF-8\"?  project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" \n     modelVersion 4.0.0 /modelVersion \n\n     groupId org.springframework.content.gs /groupId \n     artifactId gs-accessing-content-jpa /artifactId \n     version 0.1.0 /version \n\n     parent \n         groupId org.springframework.boot /groupId \n         artifactId spring-boot-starter-parent /artifactId \n         version 1.3.2.RELEASE /version \n     /parent \n\n     dependencies \n         dependency \n             groupId org.springframework.boot /groupId \n             artifactId spring-boot-starter-data-mongodb /artifactId \n         /dependency \n         dependency \n             groupId org.springframework.boot /groupId \n             artifactId spring-boot-starter-data-rest /artifactId \n         /dependency \n         dependency \n             groupId org.springframework.boot /groupId \n             artifactId spring-boot-starter-web /artifactId \n         /dependency \n         dependency \n             groupId org.springframework.boot /groupId \n             artifactId spring-content-mongo-boot-starter /artifactId \n             version 1.3.2.RELEASE /version \n         /dependency \n         dependency \n             groupId org.springframework.boot /groupId \n             artifactId spring-content-rest-boot-starter /artifactId \n             version 1.3.2.RELEASE /version \n         /dependency \n     /dependencies \n\n     properties \n         java.version 1.8 /java.version \n     /properties \n\n     build \n         plugins \n             plugin \n                 groupId org.springframework.boot /groupId \n                 artifactId spring-boot-maven-plugin /artifactId \n             /plugin \n         /plugins \n     /build  /project   The  Spring Boot Maven plugin  provides many convenient features:   It collects all the jars on the classpath and builds a single, runnable \"\u00fcber-jar\", which makes it more convenient to execute and transport your service.  It searches for the  public static void main()  method to flag as a runnable class.  It provides a built-in dependency resolver that sets the version number to match  Spring Boot dependencies . You can override any version you wish, but it will default to Boot\u2019s chosen set of versions.", 
            "title": "Create a directory structure"
        }, 
        {
            "location": "/spring-content-rest/#define-a-simple-entity-with-content", 
            "text": "In this example, you store Document objects, annotated as a Mongo entity with Content.  src/main/java/docs/SpringDocument.java  package docs;\n\nimport org.springframework.content.annotations.Content;\nimport org.springframework.content.annotations.ContentId;\nimport org.springframework.content.annotations.ContentLength;\nimport org.springframework.data.annotation.Id;\nimport org.springframework.data.mongodb.core.mapping.Document;\n\n@Document\npublic class SpringDocument {\n\n    @Id\n    private String id;\n\n    private String title;\n    private List String  keywords;\n\n    @Content\n    private ContentMetadata content;\n\n    ... getters and setters ...\n\n    public static class ContentMetadata {\n\n        public ContentMetadata() {}\n\n        @ContentId\n        private String id;\n\n        @ContentLength\n        private long length;\n\n        @MimeType\n        private String mimeType;\n\n        .. getters and setters ...\n\n    }\n}  Here you have a standard Spring Data entity bean class  SpringDocument  class with several attributes,  id ,  title ,  keywords .   Note:  For more information on Spring Data annotations see the relevant  Spring Data  documentation.   In addition this entity bean also has the  content  attribute annotated with the Spring Content annotation  @Content , indicating that instances of  ContentMetadata  are content entities.  These entities will be mapped to Mongo's GridFS.    ContentMetadata  has three attributes,  id ,  length  and  mimeType .  The  id  attribute is annotated with  @ContentId  so that Spring Content will recognize it as the content entity's ID.    The  length  attribute is annotated with  @ContentLength  so that Spring Content will recognize it as the content entity's content length.    Finally, the  mimeType  attribute is annotated with  @MimeType  so that Spring Content REST will recognize it as the content entity's mime type.  All of these annotated attributes will be managed by Spring Content.", 
            "title": "Define a simple entity with content"
        }, 
        {
            "location": "/spring-content-rest/#create-a-spring-data-repository", 
            "text": "So that we can perform simple CRUD operations, over a hypermedia-based API, create a simple repository for the  SpringDocument  class annotated with as a  @RepositoryRestResource .  src/main/java/docs/SpringDocumentRepository.java  package docs;\n\nimport org.springframework.data.repository.CrudRepository;\nimport org.springframework.data.rest.core.annotation.RepositoryRestResource;\n\n@RepositoryRestResource(path=\"/docs\", collectionResourceRel=\"docs\")\npublic interface SpringDocumentRepository extends CrudRepository SpringDocument, String  {\n\n}", 
            "title": "Create a Spring Data Repository"
        }, 
        {
            "location": "/spring-content-rest/#add-a-spring-content-repository", 
            "text": "Just like Spring Data focuses on storing data in a database, Spring Content focuses on storing content in various stores, in this case in Mongo GridFS store.  It's most compelling feature is the ability to create content store implementations automatically, at runtime, from a content store interface.  To see how this works, create a content store interface that works with SpringDocument's  ContentMetadata  entity:  src/main/java/docs/ContentMetadataContentStore.java  package docs;\n\nimport org.springframework.content.common.repository.ContentStore;\n\nimport docs.SpringDocument.ContentMetadata;\nimport internal.org.springframework.content.rest.annotations.ContentStoreRestResource;\n\n@ContentRepositoryRestResource\npublic interface ContentMetadataContentStore extends ContentStore ContentMetadata, String  {\n}  ContentMetadataContentStore  extends the  ContentStore  interface.  The type of the content entity and the type of the content entity's ID,  ContentMetadata  and  String  respectively, are specified in the generic parameters on  ContentStore .  By extending  ContentStore ,  ContentMetadataContentStore  inherits several methods for working with persisted content.  In a java application, you would expect to write an implementation for the  ContentMetadaDataContentStore  class.  But what makes Spring Content so powerful is that you don't have to do this.  Spring Content will create an implementation on the fly when you run the application.  Likewise, in a web-based application you would also expect to implement HTTP handlers allowing you to PUT and GET content over HTTP.  With Spring Content REST these are also implemented for you when you add the  ContentStoreRestResource  annotation to your content store.            Let's wire this up and see what it looks like!", 
            "title": "Add a Spring Content Repository"
        }, 
        {
            "location": "/spring-content-rest/#create-an-application-class", 
            "text": "Spring Content integrates seamlessly into Spring Boot, therefore you create the standard Application class.   src/main/java/docs/Application.java  package docs;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class ContentApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(ContentApplication.class);\n    }\n}", 
            "title": "Create an application class"
        }, 
        {
            "location": "/spring-content-rest/#build-an-executable-jar", 
            "text": "You can build a single executable JAR file that contains all the necessary dependencies, classes and resources.  This makes it easy to ship, version and deploy.  If you are using Maven, you can run the application using  mvn spring-boot:run . Or you can build the JAR file with  mvn clean package  and run the JAR by typing:  java -jar target/spring-gs-accessing-content-mongo-0.1.0.jar   Note:  The procedure above will create a runnable JAR. You can also opt to  build a classic WAR file  instead.", 
            "title": "Build an executable JAR"
        }, 
        {
            "location": "/spring-content-rest/#handle-content", 
            "text": "First create an instance of a  SpringDocument .  Using curl, issue the following command:  curl -XPOST -H 'Content-Type:application/json' -d '{\"title\":\"test doc\",\"keywords\":[\"one\",\"two\"]}' http://localhost:8080/docs  Check that this  SpringDocument  was created by issing the following command:  curl http://localhost:8080/docs  and this should respond with:  {\n  \"_embedded\" : {\n    \"docs\" : [ {\n      \"title\" : \"test doc\",\n      \"keywords\" : [ \"one\", \"two\" ],\n      \"content\" : null,\n      \"_links\" : {\n        \"self\" : {\n          \"href\" : \"http://localhost:8080/docs/5636224fa82677aa529322b6\"\n        }\n      }\n    } ]\n  }\n}  which shows us there is one document that may be fetched with a  GET  request to  http://localhost:8080/docs/5636224fa82677aa529322b6   Note:  you're IDs will obviously be different, adjust as appropriate   Notice, that the  content  attribute is null.  That is because we haven't added any content yet so let's add some, issue the following command:  curl -XPOST -F file=@/tmp/test.txt http://localhost:8080/docs/5636224fa82677aa529322b6/content   Note:  In our example /tmp/test.txt contains the simple plain text  Hello Spring Content World!  but this could be any binary content   Now, re-query the original  SpringDocument  again:-  curl http://localhost:8080/docs/5636224fa82677aa529322b6  This time it should respond with:  {\n  \"title\" : \"test doc\",\n  \"keywords\" : [ \"one\", \"two\" ],\n  \"content\" : {\n    \"length\" : 28,\n    \"mimeType\" : \"text/plain\"\n  },\n  \"_links\" : {\n    \"self\" : {\n      \"href\" : \"http://localhost:8080/docs/5636224fa82677aa529322b6\"\n    },\n    \"content\" : {\n      \"href\" : \"http://localhost:8080/docs/5636224fa82677aa529322b6/content/64bf2339-c8e5-44f1-b960-aeb9ea8e4a7e\"\n    }\n  }\n}  We see the  content  attribute now contains useful information about the document's content, namely  length  and  mimeType .  These were set automatically by Spring Content.  Similarly,  _links  also now contains a linkrel for  content  allowing clients to navigate from this  SpringDocument  resource to it's content.  Let's do that now, issue the command:  http://localhost:8080/docs/5636224fa82677aa529322b6/content/64bf2339-c8e5-44f1-b960-aeb9ea8e4a7e  which responds:  Hello Spring Content World!", 
            "title": "Handle Content"
        }, 
        {
            "location": "/spring-content-rest/#summary", 
            "text": "Congratulations!  You've written a simple application that uses Spring Content and Spring Content REST to save objects with content to a database and to fetch them again using a hypermedia-based REST API - all without writing a single concrete implementation class.", 
            "title": "Summary"
        }
    ]
}