{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Spring Content Cloud-Native Content Services for Spring. For creating services that manage content such as documents, images and movies. Build your own cloud-native, scale-out headless content services using the exact same components as the Enterprise Content Management (ECM) vendors such as Documentum and OpenText, without the hassle. Features Standardized content access no matter where it is stored Content/metadata association Content search Content transformation REST or CMIS endpoints Videos An Overview of Spring Content SpringOne 2016 - Persistence Arrives on Cloud Foundry SpringOne 2017 - A Guided Tour From Code Base To Platform 11:28 - 21:58 SpringOne 2018 - From Content Management to Content Services with Spring Boot, Data and Content Modules Spring Content Commons - Core Spring concepts underpinning every Spring Content project. Spring Content S3 - Store support for Amazon S3 objects. Also supports DellEMC ECS Spring Content Filesystem - Store support for the Filesystem files Spring Content Mongo - Store support for Mongo's GridFS Spring Content JPA - Store support for JPA BLOBs Spring Content Renditions - Extensible rendition service for content transformations Spring Content Solr - Content indexing and search with Apache Solr Spring Content Elasticsearch - Content indexing and search with Elasticsearch Spring Versions Commons - Locking and versioning semantics for Entities and associated content Spring Versions JPA - JPA-based implementation of locking and versioning Spring Data REST - Exports Spring Content stores as hypermedia-driven RESTful resources Spring Content CMIS - Exports Spring Content stores through the CMIS browser bindings Overview Figure 1. understanding how Spring Content fits into the Spring eco-system Quick Start {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-fs/complete/pom.xml 38-42} For a quick taste, look at the following domain object: {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-fs/complete/src/main/java/gettingstarted/File.java 17-33} This defines a simple JPA entity with a few structured data fields; title, authors and keywords and two Spring Content-managed data fields; @ContentId and @ContentLength . The structured data fields are managed in the usual way through a CrudRepository<SopDocument,String> interface. Content is handled separately with a ContentStore interface:- {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-fs/complete/src/main/java/gettingstarted/FileContentStore.java 5-6} This interface extends Spring Content\u2019s ContentStore and is typed to the entity class File and the id class String. Put this code inside a Spring Boot application with spring-boot-starter-data-jpa and spring-content-fs-boot-starter like this: {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-fs/complete/src/main/java/gettingstarted/SpringContentApplication.java 6-12} Launch your app and Spring Content (having been autoconfigured by Spring Boot) will automatically craft a concrete set of operations for handling the content associated with this Entity: setContent(S property, InputStream content) InputStream getContent(S property) unsetContent(S property) For more, check out our initial Getting Started Guide , or watch one of our SpringOne talks 2016 , 2017 @11mins and 2018 . Releases Reference Documentation Spring Boot 2.1.x Spring Boot 2.2.x Spring Boot 2.3.x GA SNAPSHOT GA SNAPSHOT GA Storage Spring Content S3 0.12.0 1.0.0.M11 1.0.0.M10 1.1.0.M5-SNAPSHOT 1.1.0.M4 Spring Content Filesystem 0.12.0 1.0.0.M11 1.0.0.M10 1.1.0.M5-SNAPSHOT 1.1.0.M4 Spring Content Mongo 0.12.0 1.0.0.M11 1.0.0.M10 1.1.0.M5-SNAPSHOT 1.1.0.M4 Spring Content JPA 0.12.0 1.0.0.M11 1.0.0.M10 1.1.0.M5-SNAPSHOT 1.1.0.M4 Renditions Spring Content Renditions - - - 1.1.0.M5-SNAPSHOT 1.1.0.M4 Versioning Spring Versions JPA 0.12.0 1.0.0.M11 1.0.0.M10 1.1.0.M5-SNAPSHOT 1.1.0.M4 Fulltext Indexing Spring Content Solr 0.12.0 1.0.0.M11 1.0.0.M10 1.1.0.M5-SNAPSHOT 1.1.0.M4 Spring Content Elasticsearch 0.12.0 1.0.0.M11 1.0.0.M10 1.1.0.M5-SNAPSHOT 1.1.0.M4 APIs Spring Content REST 0.12.0 1.0.0.M11 1.0.0.M10 1.1.0.M5-SNAPSHOT 1.1.0.M4 Spring Content CMIS 0.12.0 1.0.0.M11 1.0.0.M10 1.1.0.M5-SNAPSHOT 1.1.0.M4","title":"Home"},{"location":"#spring-content","text":"Cloud-Native Content Services for Spring. For creating services that manage content such as documents, images and movies. Build your own cloud-native, scale-out headless content services using the exact same components as the Enterprise Content Management (ECM) vendors such as Documentum and OpenText, without the hassle.","title":"Spring Content"},{"location":"#features","text":"Standardized content access no matter where it is stored Content/metadata association Content search Content transformation REST or CMIS endpoints","title":"Features"},{"location":"#videos","text":"An Overview of Spring Content SpringOne 2016 - Persistence Arrives on Cloud Foundry SpringOne 2017 - A Guided Tour From Code Base To Platform 11:28 - 21:58 SpringOne 2018 - From Content Management to Content Services with Spring Boot, Data and Content","title":"Videos"},{"location":"#modules","text":"Spring Content Commons - Core Spring concepts underpinning every Spring Content project. Spring Content S3 - Store support for Amazon S3 objects. Also supports DellEMC ECS Spring Content Filesystem - Store support for the Filesystem files Spring Content Mongo - Store support for Mongo's GridFS Spring Content JPA - Store support for JPA BLOBs Spring Content Renditions - Extensible rendition service for content transformations Spring Content Solr - Content indexing and search with Apache Solr Spring Content Elasticsearch - Content indexing and search with Elasticsearch Spring Versions Commons - Locking and versioning semantics for Entities and associated content Spring Versions JPA - JPA-based implementation of locking and versioning Spring Data REST - Exports Spring Content stores as hypermedia-driven RESTful resources Spring Content CMIS - Exports Spring Content stores through the CMIS browser bindings","title":"Modules"},{"location":"#overview","text":"Figure 1. understanding how Spring Content fits into the Spring eco-system","title":"Overview"},{"location":"#quick-start","text":"{snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-fs/complete/pom.xml 38-42} For a quick taste, look at the following domain object: {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-fs/complete/src/main/java/gettingstarted/File.java 17-33} This defines a simple JPA entity with a few structured data fields; title, authors and keywords and two Spring Content-managed data fields; @ContentId and @ContentLength . The structured data fields are managed in the usual way through a CrudRepository<SopDocument,String> interface. Content is handled separately with a ContentStore interface:- {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-fs/complete/src/main/java/gettingstarted/FileContentStore.java 5-6} This interface extends Spring Content\u2019s ContentStore and is typed to the entity class File and the id class String. Put this code inside a Spring Boot application with spring-boot-starter-data-jpa and spring-content-fs-boot-starter like this: {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-fs/complete/src/main/java/gettingstarted/SpringContentApplication.java 6-12} Launch your app and Spring Content (having been autoconfigured by Spring Boot) will automatically craft a concrete set of operations for handling the content associated with this Entity: setContent(S property, InputStream content) InputStream getContent(S property) unsetContent(S property) For more, check out our initial Getting Started Guide , or watch one of our SpringOne talks 2016 , 2017 @11mins and 2018 .","title":"Quick Start"},{"location":"#releases","text":"","title":"Releases"},{"location":"#reference-documentation","text":"Spring Boot 2.1.x Spring Boot 2.2.x Spring Boot 2.3.x GA SNAPSHOT GA SNAPSHOT GA Storage Spring Content S3 0.12.0 1.0.0.M11 1.0.0.M10 1.1.0.M5-SNAPSHOT 1.1.0.M4 Spring Content Filesystem 0.12.0 1.0.0.M11 1.0.0.M10 1.1.0.M5-SNAPSHOT 1.1.0.M4 Spring Content Mongo 0.12.0 1.0.0.M11 1.0.0.M10 1.1.0.M5-SNAPSHOT 1.1.0.M4 Spring Content JPA 0.12.0 1.0.0.M11 1.0.0.M10 1.1.0.M5-SNAPSHOT 1.1.0.M4 Renditions Spring Content Renditions - - - 1.1.0.M5-SNAPSHOT 1.1.0.M4 Versioning Spring Versions JPA 0.12.0 1.0.0.M11 1.0.0.M10 1.1.0.M5-SNAPSHOT 1.1.0.M4 Fulltext Indexing Spring Content Solr 0.12.0 1.0.0.M11 1.0.0.M10 1.1.0.M5-SNAPSHOT 1.1.0.M4 Spring Content Elasticsearch 0.12.0 1.0.0.M11 1.0.0.M10 1.1.0.M5-SNAPSHOT 1.1.0.M4 APIs Spring Content REST 0.12.0 1.0.0.M11 1.0.0.M10 1.1.0.M5-SNAPSHOT 1.1.0.M4 Spring Content CMIS 0.12.0 1.0.0.M11 1.0.0.M10 1.1.0.M5-SNAPSHOT 1.1.0.M4","title":"Reference Documentation"},{"location":"spring-content-fs-docs/","text":"Getting Started with Spring Content What you'll build You'll build an application that uses Spring Content to build a simple web-based document list. What you'll need About 30 minutes A favorite text editor or IDE JDK 1.8 or later Maven 3.0+ You can also import the code from this guide as well as view the web page directly into Spring Tool Suite (STS) and work your way through it from there. How to complete this guide Like most Spring Getting Started guides, you can start form scratch and complete each step, or you can bypass basic setup steps that are already familiar to you. Either way, you end up with working code. To start from scratch, move on to Build with Maven. To skip the basics, do the following: Download and unzip the source repository for this guide, or clone it using Git: git clone https://github.com/paulcwarren/spring-content-gettingstarted.git cd into spring-content-gettingstarted/spring-content-fs/initial Jump ahead to Define a simple entity . When you\u2019re finished, you can check your results against the code in spring-content-gettingstarted/spring-content-fs/complete . Build with Maven First you set up a basic build script. You can use any build system you like when building apps with Spring, but the code you need to work with Maven is included here. If you\u2019re not familiar with Maven, refer to Building Java Projects with Maven . Create a directory structure In a project directory of your choosing, create the following subdirectory structure; for example, with mkdir -p src/main/java/gettingstarted on *nix systems: \u221f src \u221f main \u221f java \u221f gettingstarted \u221f resources \u221f static pom.xml {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-fs/complete/pom.xml 1-} We add several dependencies:- Spring Boot Starter Web provides the web server framework Spring Boot Starter Data JPA will provide a relational database to store the metadata of our files. In this case we are using the H2 in-memory database Spring Boot Starter Data REST will provide REST endpoints for our File metadata Spring Boot Starter Content FS will provide a Filesystem-based store for the content of each file and manage the association with an Entity Define a simple Entity Let's define a simple Entity to represent a File. src/main/java/gettingstarted/File.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-fs/complete/src/main/java/gettingstarted/File.java 1-} As you would expect we created a standard JPA Entity to capture some metadata about our file; name and summary . In addition, because we will be serving these files over the web, we also record mimeType so that we can instruct the browser correctly. We then add two annotated Spring Content fields; @ContentId and @ContentLength . @ContentId allows us to associate a stream of binary data with an Entity and @ContentLength records the length of that stream. These will be automatically managed by Spring Content. Create a File Repository Next, as you would also expect, we create a CrudRepository for handling File entities and we export it as a @RepositoryRestResource so, for the cost of writing just one interface and annotating it, we get the ability to create, read, update and delete File entities using REST endpoints. NB. For more information on Spring Data JPA and Spring Data REST see their respective spring.io getting started guides. src/main/java/gettingstated/FileRepository.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-fs/complete/src/main/java/gettingstarted/FileRepository.java 1-} Create a File Content Store Similarly, we then create a ContentStore for handling content associated with the File entity. src/main/java/gettngstarted/FileContentStore.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-fs/complete/src/main/java/gettingstarted/FileContentStore.java 1-} Let's investigate this interface:- ContentStore provides several methods for handling content; setContent, getContent and unsetContent The dependency com.github.paulcwarren:spring-content-fs-boot-starter provides a Filesystem-based implementation of this interface and Spring Content auto-configuration ensures that this implementation will be used wherever the FileContentRepository is @Autowired . However, unlike our FileRepository we haven't annotated this as a StoreRestResource and therefore we don't automatically get REST endpoints for handling content. This annotation does exist (and is the topic of our next tutorial ) but, for now, we have to roll our own REST endpoints. Create a File Controller Let's create these endpoints with a simple Controller class. src/main/java/gettingstarted/FileContentController.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-fs/complete/src/main/java/gettingstarted/FileContentController.java 1-} Let's explain this class. It's a standard Spring Controller with two request mapped methods, one for setting content and the other for getting content. Both setContent and getContent methods inject themselves into the URI space of the FileRepository , namely /files/{fileId} , but handle all GETs and PUTs that are aplication/hal+json based; i.e. content. We inject our FileRepository and our FileContentStore . Respectively, Spring Boot will ensure real implementations are injected (based on what Spring Data and Spring Content modules are found on the class path). setContent uses the FileRepository to fetch the File entity using the given fileId and then uses the FileContentStore to save the given file input stream. Similarly, getContent uses the FileRepository to fetch the File entity using the given fileId and again use the FileContentStore to fetch the associated content and stream it back to the client as the response. We also use previosuly saved metdata contentLength and mimeType to set http headers appropriately. This will mean that browsers can handle the content correctly by launching the relevant desktop application. Create Web Client Now let's create a really simple angular web front-end for our document list. src/main/resources/static/index.html {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-fs/complete/src/main/resources/static/index.html 1-} This HTML presents a simple list of files using an ng-repeat directive and contains a simple form allowing new files to be uploaded. All the interesting code is in the code-behind file so add the following code behind to src/main/resources/static/files.js {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-fs/complete/src/main/resources/static/files.js 1-} This angular controller has the following functions:- getFilesList queries our FileRepository via its REST endpoint files/ and populates filesList.files (presented by the ng-repeat directive in the HTML) getHref returns a file 's content hyperlink files/{fileId} (that ultimately calls FileContentController.getContent ) upload uploads a new File by first POST ing to the FileRepository REST endpoints /files and once created PUT ing the actual content to the Files content REST endpoint files/{fileId} (that ultimately calls FileContentController.setContent ) Create an Application class Our simple document list app is now complete. All that remains is to add the usual Spring Boot Application class. src/main/java/gettingstarted/SpringContentApplication.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-fs/complete/src/main/java/gettingstarted/SpringContentApplication.java 1-} Build an executable JAR If you are using Maven, you can run the application using mvn spring-boot:run . Or you can build the JAR file with mvn clean package and run the JAR by typing: java -jar target/gettingstarted-spring-content-fs-0.0.1.jar And then point your browser at:- http://localhost:8080 and you should see something like this:- Exercise the application by uploading a range of new files and viewing them. Viewed files will be downloaded and open in the appropriate editor. Summary Congratulations! You\u2019ve written a simple application that uses Spring Content to manage streams of binary data - without writing any specific file access code. What's more by just changing the type of the spring-content boot-starter project on the classpath you can switch from a file-based implementation to a different implementation altogether. Spring Content supports the following implementations:- Spring Content Filesystem; stores content as Files on the Filesystem (as used in this tutorial) Spring Content S3; stores content as Objects in Amazon S3 Spring Content JPA; stores content as BLOBs in the database Spring Content MongoDB; stores content as Resources in Mongo's GridFS Look Forward In this tutorial we built a simple document list web application using Spring Content. The majority of the work on the server-side was writing the Spring controller for handling the Content. Check out our next getting started guide where we'll use the companion library Spring Content REST to automatically export these REST endpoints for our FileContentStore saving ourselves even more work.","title":"Java API"},{"location":"spring-content-fs-docs/#getting-started-with-spring-content","text":"","title":"Getting Started with Spring Content"},{"location":"spring-content-fs-docs/#what-youll-build","text":"You'll build an application that uses Spring Content to build a simple web-based document list.","title":"What you'll build"},{"location":"spring-content-fs-docs/#what-youll-need","text":"About 30 minutes A favorite text editor or IDE JDK 1.8 or later Maven 3.0+ You can also import the code from this guide as well as view the web page directly into Spring Tool Suite (STS) and work your way through it from there.","title":"What you'll need"},{"location":"spring-content-fs-docs/#how-to-complete-this-guide","text":"Like most Spring Getting Started guides, you can start form scratch and complete each step, or you can bypass basic setup steps that are already familiar to you. Either way, you end up with working code. To start from scratch, move on to Build with Maven. To skip the basics, do the following: Download and unzip the source repository for this guide, or clone it using Git: git clone https://github.com/paulcwarren/spring-content-gettingstarted.git cd into spring-content-gettingstarted/spring-content-fs/initial Jump ahead to Define a simple entity . When you\u2019re finished, you can check your results against the code in spring-content-gettingstarted/spring-content-fs/complete .","title":"How to complete this guide"},{"location":"spring-content-fs-docs/#build-with-maven","text":"First you set up a basic build script. You can use any build system you like when building apps with Spring, but the code you need to work with Maven is included here. If you\u2019re not familiar with Maven, refer to Building Java Projects with Maven .","title":"Build with Maven"},{"location":"spring-content-fs-docs/#create-a-directory-structure","text":"In a project directory of your choosing, create the following subdirectory structure; for example, with mkdir -p src/main/java/gettingstarted on *nix systems: \u221f src \u221f main \u221f java \u221f gettingstarted \u221f resources \u221f static pom.xml {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-fs/complete/pom.xml 1-} We add several dependencies:- Spring Boot Starter Web provides the web server framework Spring Boot Starter Data JPA will provide a relational database to store the metadata of our files. In this case we are using the H2 in-memory database Spring Boot Starter Data REST will provide REST endpoints for our File metadata Spring Boot Starter Content FS will provide a Filesystem-based store for the content of each file and manage the association with an Entity","title":"Create a directory structure"},{"location":"spring-content-fs-docs/#define-a-simple-entity","text":"Let's define a simple Entity to represent a File. src/main/java/gettingstarted/File.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-fs/complete/src/main/java/gettingstarted/File.java 1-} As you would expect we created a standard JPA Entity to capture some metadata about our file; name and summary . In addition, because we will be serving these files over the web, we also record mimeType so that we can instruct the browser correctly. We then add two annotated Spring Content fields; @ContentId and @ContentLength . @ContentId allows us to associate a stream of binary data with an Entity and @ContentLength records the length of that stream. These will be automatically managed by Spring Content.","title":"Define a simple Entity"},{"location":"spring-content-fs-docs/#create-a-file-repository","text":"Next, as you would also expect, we create a CrudRepository for handling File entities and we export it as a @RepositoryRestResource so, for the cost of writing just one interface and annotating it, we get the ability to create, read, update and delete File entities using REST endpoints. NB. For more information on Spring Data JPA and Spring Data REST see their respective spring.io getting started guides. src/main/java/gettingstated/FileRepository.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-fs/complete/src/main/java/gettingstarted/FileRepository.java 1-}","title":"Create a File Repository"},{"location":"spring-content-fs-docs/#create-a-file-content-store","text":"Similarly, we then create a ContentStore for handling content associated with the File entity. src/main/java/gettngstarted/FileContentStore.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-fs/complete/src/main/java/gettingstarted/FileContentStore.java 1-} Let's investigate this interface:- ContentStore provides several methods for handling content; setContent, getContent and unsetContent The dependency com.github.paulcwarren:spring-content-fs-boot-starter provides a Filesystem-based implementation of this interface and Spring Content auto-configuration ensures that this implementation will be used wherever the FileContentRepository is @Autowired . However, unlike our FileRepository we haven't annotated this as a StoreRestResource and therefore we don't automatically get REST endpoints for handling content. This annotation does exist (and is the topic of our next tutorial ) but, for now, we have to roll our own REST endpoints.","title":"Create a File Content Store"},{"location":"spring-content-fs-docs/#create-a-file-controller","text":"Let's create these endpoints with a simple Controller class. src/main/java/gettingstarted/FileContentController.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-fs/complete/src/main/java/gettingstarted/FileContentController.java 1-} Let's explain this class. It's a standard Spring Controller with two request mapped methods, one for setting content and the other for getting content. Both setContent and getContent methods inject themselves into the URI space of the FileRepository , namely /files/{fileId} , but handle all GETs and PUTs that are aplication/hal+json based; i.e. content. We inject our FileRepository and our FileContentStore . Respectively, Spring Boot will ensure real implementations are injected (based on what Spring Data and Spring Content modules are found on the class path). setContent uses the FileRepository to fetch the File entity using the given fileId and then uses the FileContentStore to save the given file input stream. Similarly, getContent uses the FileRepository to fetch the File entity using the given fileId and again use the FileContentStore to fetch the associated content and stream it back to the client as the response. We also use previosuly saved metdata contentLength and mimeType to set http headers appropriately. This will mean that browsers can handle the content correctly by launching the relevant desktop application.","title":"Create a File Controller"},{"location":"spring-content-fs-docs/#create-web-client","text":"Now let's create a really simple angular web front-end for our document list. src/main/resources/static/index.html {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-fs/complete/src/main/resources/static/index.html 1-} This HTML presents a simple list of files using an ng-repeat directive and contains a simple form allowing new files to be uploaded. All the interesting code is in the code-behind file so add the following code behind to src/main/resources/static/files.js {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-fs/complete/src/main/resources/static/files.js 1-} This angular controller has the following functions:- getFilesList queries our FileRepository via its REST endpoint files/ and populates filesList.files (presented by the ng-repeat directive in the HTML) getHref returns a file 's content hyperlink files/{fileId} (that ultimately calls FileContentController.getContent ) upload uploads a new File by first POST ing to the FileRepository REST endpoints /files and once created PUT ing the actual content to the Files content REST endpoint files/{fileId} (that ultimately calls FileContentController.setContent )","title":"Create Web Client"},{"location":"spring-content-fs-docs/#create-an-application-class","text":"Our simple document list app is now complete. All that remains is to add the usual Spring Boot Application class. src/main/java/gettingstarted/SpringContentApplication.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-fs/complete/src/main/java/gettingstarted/SpringContentApplication.java 1-}","title":"Create an Application class"},{"location":"spring-content-fs-docs/#build-an-executable-jar","text":"If you are using Maven, you can run the application using mvn spring-boot:run . Or you can build the JAR file with mvn clean package and run the JAR by typing: java -jar target/gettingstarted-spring-content-fs-0.0.1.jar And then point your browser at:- http://localhost:8080 and you should see something like this:- Exercise the application by uploading a range of new files and viewing them. Viewed files will be downloaded and open in the appropriate editor.","title":"Build an executable JAR"},{"location":"spring-content-fs-docs/#summary","text":"Congratulations! You\u2019ve written a simple application that uses Spring Content to manage streams of binary data - without writing any specific file access code. What's more by just changing the type of the spring-content boot-starter project on the classpath you can switch from a file-based implementation to a different implementation altogether. Spring Content supports the following implementations:- Spring Content Filesystem; stores content as Files on the Filesystem (as used in this tutorial) Spring Content S3; stores content as Objects in Amazon S3 Spring Content JPA; stores content as BLOBs in the database Spring Content MongoDB; stores content as Resources in Mongo's GridFS","title":"Summary"},{"location":"spring-content-fs-docs/#look-forward","text":"In this tutorial we built a simple document list web application using Spring Content. The majority of the work on the server-side was writing the Spring controller for handling the Content. Check out our next getting started guide where we'll use the companion library Spring Content REST to automatically export these REST endpoints for our FileContentStore saving ourselves even more work.","title":"Look Forward"},{"location":"spring-content-rest-docs/","text":"Getting Started with Spring Content REST What you'll build You'll remove redundant code from the document list web application that we produced in our first Getting Started Guide . What you'll need About 30 minutes A favorite text editor or IDE JDK 1.8 or later Maven 3.0+ How to complete this guide Before we begin let's set up our development environment: Download and unzip the source repository for this guide, or clone it using Git: git clone https://github.com/paulcwarren/spring-content-gettingstarted.git We are going to start form where we left of in the last Getting Started Guide so cd into spring-content-gettingstarted/spring-content-fs/complete Move ahead to Update dependencies . When you\u2019re finished, you can check your results against the code in spring-content-gettingstarted/spring-content-rest/complete . Update dependencies Add the com.github.paulcwarren:spring-content-rest-boot-starter dependency. pom.xml {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-rest/complete/pom.xml 1-} Update File Entity Add the @MimeType marker annotation to our Entity. src/main/java/gettingstarted/File.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-rest/complete/src/main/java/gettingstarted/File.java 1-} The mimeType attribute is updated with the Spring Content @MimeType annotation so that Spring Content REST will update its value on our behalf. Update FileContentStore So that we can perform simple CRUD operations, over a hypermedia-based API, update our FileContentStore by annotating it with the @StoreRestResource Spring Content REST annotation. src/main/java/gettingstarted/FileContentStore.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-rest/complete/src/main/java/gettingstarted/FileContentStore.java 1-} Remove FileContentController Having made the above updates we can remove our FileContentController as it is now surplus to requirements. Spring Content REST will provide these endpoints for us. Build an executable JAR If you are using Maven, you can run the application using mvn spring-boot:run . Or you can build the JAR file with mvn clean package and run the JAR by typing: java -jar target/gettingstarted-spring-content-rest-0.0.1.jar And then point your browser at:- http://localhost:8080 and you should see something like this:- As you did in the previous tutorial, exercise the application by uploading a range of new files and viewing them. You should see viewed files open as they did before. Summary Congratulations! You've written a simple application that uses Spring Content and Spring Content REST to save objects with content to the file-system and to fetch them again using a hypermedia-based REST API - all without writing any implementation code to handle file access. Don't forget you can simply change the type of the spring-content bootstarter project on the classpath to switch from file storage to a different storage medium. Spring Content REST works seamlessly with all of the storage modules. Spring Content supports the following implementations:- Spring Content Filesystem; stores content as Files on the Filesystem (as used in this tutorial) Spring Content S3; stores content as Objects in Amazon S3 Spring Content JPA; stores content as BLOBs in the database Spring Content MongoDB; stores content as Resources in Mongo's GridFS","title":"REST API"},{"location":"spring-content-rest-docs/#getting-started-with-spring-content-rest","text":"","title":"Getting Started with Spring Content REST"},{"location":"spring-content-rest-docs/#what-youll-build","text":"You'll remove redundant code from the document list web application that we produced in our first Getting Started Guide .","title":"What you'll build"},{"location":"spring-content-rest-docs/#what-youll-need","text":"About 30 minutes A favorite text editor or IDE JDK 1.8 or later Maven 3.0+","title":"What you'll need"},{"location":"spring-content-rest-docs/#how-to-complete-this-guide","text":"Before we begin let's set up our development environment: Download and unzip the source repository for this guide, or clone it using Git: git clone https://github.com/paulcwarren/spring-content-gettingstarted.git We are going to start form where we left of in the last Getting Started Guide so cd into spring-content-gettingstarted/spring-content-fs/complete Move ahead to Update dependencies . When you\u2019re finished, you can check your results against the code in spring-content-gettingstarted/spring-content-rest/complete .","title":"How to complete this guide"},{"location":"spring-content-rest-docs/#update-dependencies","text":"Add the com.github.paulcwarren:spring-content-rest-boot-starter dependency. pom.xml {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-rest/complete/pom.xml 1-}","title":"Update dependencies"},{"location":"spring-content-rest-docs/#update-file-entity","text":"Add the @MimeType marker annotation to our Entity. src/main/java/gettingstarted/File.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-rest/complete/src/main/java/gettingstarted/File.java 1-} The mimeType attribute is updated with the Spring Content @MimeType annotation so that Spring Content REST will update its value on our behalf.","title":"Update File Entity"},{"location":"spring-content-rest-docs/#update-filecontentstore","text":"So that we can perform simple CRUD operations, over a hypermedia-based API, update our FileContentStore by annotating it with the @StoreRestResource Spring Content REST annotation. src/main/java/gettingstarted/FileContentStore.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-rest/complete/src/main/java/gettingstarted/FileContentStore.java 1-}","title":"Update FileContentStore"},{"location":"spring-content-rest-docs/#remove-filecontentcontroller","text":"Having made the above updates we can remove our FileContentController as it is now surplus to requirements. Spring Content REST will provide these endpoints for us.","title":"Remove FileContentController"},{"location":"spring-content-rest-docs/#build-an-executable-jar","text":"If you are using Maven, you can run the application using mvn spring-boot:run . Or you can build the JAR file with mvn clean package and run the JAR by typing: java -jar target/gettingstarted-spring-content-rest-0.0.1.jar And then point your browser at:- http://localhost:8080 and you should see something like this:- As you did in the previous tutorial, exercise the application by uploading a range of new files and viewing them. You should see viewed files open as they did before.","title":"Build an executable JAR"},{"location":"spring-content-rest-docs/#summary","text":"Congratulations! You've written a simple application that uses Spring Content and Spring Content REST to save objects with content to the file-system and to fetch them again using a hypermedia-based REST API - all without writing any implementation code to handle file access. Don't forget you can simply change the type of the spring-content bootstarter project on the classpath to switch from file storage to a different storage medium. Spring Content REST works seamlessly with all of the storage modules. Spring Content supports the following implementations:- Spring Content Filesystem; stores content as Files on the Filesystem (as used in this tutorial) Spring Content S3; stores content as Objects in Amazon S3 Spring Content JPA; stores content as BLOBs in the database Spring Content MongoDB; stores content as Resources in Mongo's GridFS","title":"Summary"},{"location":"spring-content-with-fulltext-docs/","text":"Getting Started Spring Content with Fulltext What you'll build We'll build on the previous guide Getting Started with Spring Content REST API . What you'll need About 30 minutes A favorite text editor or IDE JDK 1.8 or later Maven 3.0+ How to complete this guide Before we begin let's set up our development environment: Download and unzip the source repository for this guide, or clone it using Git: git clone https://github.com/paulcwarren/spring-content-gettingstarted.git We are going to start where Getting Started with Spring Content REST API leaves off so cd into spring-content-gettingstarted/spring-content-rest/complete When you\u2019re finished, you can check your results against the code in spring-content-gettingstarted/spring-content-with-fulltext/complete . Update dependencies Add the com.github.paulcwarren:spring-content-elasticsearch-boot-starter and org.elasticsearch.client:elasticsearch-rest-high-level-client dependencies. pom.xml {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-with-fulltext/complete/pom.xml 1-} Update FileContentStore So that we can perform full-text searches make your FileContentStore extend Searchable . src/main/java/gettingstarted/FileContentStore.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-with-fulltext/complete/src/main/java/gettingstarted/FileContentStore.java 1-} Build an executable JAR If you are using Maven, you can run the application using mvn spring-boot:run . Or you can build the JAR file with mvn clean package and run the JAR by typing: java -jar target/gettingstarted-spring-content-with-versions-0.0.1.jar Start an Elasticsearch Server Using docker, start an elasticsearch server: docker run -d -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" paulcwarren/elasticsearch:latest Create an Entity Create an entity: curl -X POST -H 'Content-Type:application/hal+json' -d '{}' http://localhost:8080/files/ Associate content with that entity: curl -X PUT -H 'Content-Type:text/plain' -d 'Hello Spring World!' http://localhost:8080/files/1 Create a second entity: curl -X POST -H 'Content-Type:application/hal+json' -d '{}' http://localhost:8080/files/ Associate content with the second entity: curl -X PUT -H 'Content-Type:text/plain' -d 'Hello Spring Content World!' http://localhost:8080/files/2 Perform a fulltext search using the /searchContent endpoint: curl -H 'Accept:application/hal+json' http://localhost:8080/files/searchContent?queryString=Content And you should see a response like this: { \"_embedded\" : { \"files\" : [ { \"name\" : null, \"created\" : \"2020-05-14T06:05:07.633+0000\", \"summary\" : null, \"contentId\" : \"527638d0-4f08-469d-a7d7-b271316af3da\", \"contentLength\" : 27, \"mimeType\" : \"text/plain\", \"_links\" : { \"self\" : { \"href\" : \"http://localhost:8080/files/2\" }, \"file\" : { \"href\" : \"http://localhost:8080/files/2\" }, \"files\" : { \"href\" : \"http://localhost:8080/files/2\" } } } ] }, \"_links\" : { \"self\" : { \"href\" : \"http://localhost:8080/files/searchContent?queryString=Content\" } } } Spring Content found the second document that we added because its content included the keyword \"Content\" that we searched for. Summary Congratulations! You've just written a simple application that uses Spring Content with Elasticsearch to index content so that searches can be performed against that content. This guide demonstrates the Spring Content Elasticsearch Module. Spring Content also supports Solr with the Spring Content Solr Module. To use Solr, simply update the spring-content-elasticsearch-boot-starter dependency for spring-content-solr-boot-starter .","title":"Fulltext"},{"location":"spring-content-with-fulltext-docs/#getting-started-spring-content-with-fulltext","text":"","title":"Getting Started Spring Content with Fulltext"},{"location":"spring-content-with-fulltext-docs/#what-youll-build","text":"We'll build on the previous guide Getting Started with Spring Content REST API .","title":"What you'll build"},{"location":"spring-content-with-fulltext-docs/#what-youll-need","text":"About 30 minutes A favorite text editor or IDE JDK 1.8 or later Maven 3.0+","title":"What you'll need"},{"location":"spring-content-with-fulltext-docs/#how-to-complete-this-guide","text":"Before we begin let's set up our development environment: Download and unzip the source repository for this guide, or clone it using Git: git clone https://github.com/paulcwarren/spring-content-gettingstarted.git We are going to start where Getting Started with Spring Content REST API leaves off so cd into spring-content-gettingstarted/spring-content-rest/complete When you\u2019re finished, you can check your results against the code in spring-content-gettingstarted/spring-content-with-fulltext/complete .","title":"How to complete this guide"},{"location":"spring-content-with-fulltext-docs/#update-dependencies","text":"Add the com.github.paulcwarren:spring-content-elasticsearch-boot-starter and org.elasticsearch.client:elasticsearch-rest-high-level-client dependencies. pom.xml {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-with-fulltext/complete/pom.xml 1-}","title":"Update dependencies"},{"location":"spring-content-with-fulltext-docs/#update-filecontentstore","text":"So that we can perform full-text searches make your FileContentStore extend Searchable . src/main/java/gettingstarted/FileContentStore.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-with-fulltext/complete/src/main/java/gettingstarted/FileContentStore.java 1-}","title":"Update FileContentStore"},{"location":"spring-content-with-fulltext-docs/#build-an-executable-jar","text":"If you are using Maven, you can run the application using mvn spring-boot:run . Or you can build the JAR file with mvn clean package and run the JAR by typing: java -jar target/gettingstarted-spring-content-with-versions-0.0.1.jar","title":"Build an executable JAR"},{"location":"spring-content-with-fulltext-docs/#start-an-elasticsearch-server","text":"Using docker, start an elasticsearch server: docker run -d -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" paulcwarren/elasticsearch:latest","title":"Start an Elasticsearch Server"},{"location":"spring-content-with-fulltext-docs/#create-an-entity","text":"Create an entity: curl -X POST -H 'Content-Type:application/hal+json' -d '{}' http://localhost:8080/files/ Associate content with that entity: curl -X PUT -H 'Content-Type:text/plain' -d 'Hello Spring World!' http://localhost:8080/files/1 Create a second entity: curl -X POST -H 'Content-Type:application/hal+json' -d '{}' http://localhost:8080/files/ Associate content with the second entity: curl -X PUT -H 'Content-Type:text/plain' -d 'Hello Spring Content World!' http://localhost:8080/files/2 Perform a fulltext search using the /searchContent endpoint: curl -H 'Accept:application/hal+json' http://localhost:8080/files/searchContent?queryString=Content And you should see a response like this: { \"_embedded\" : { \"files\" : [ { \"name\" : null, \"created\" : \"2020-05-14T06:05:07.633+0000\", \"summary\" : null, \"contentId\" : \"527638d0-4f08-469d-a7d7-b271316af3da\", \"contentLength\" : 27, \"mimeType\" : \"text/plain\", \"_links\" : { \"self\" : { \"href\" : \"http://localhost:8080/files/2\" }, \"file\" : { \"href\" : \"http://localhost:8080/files/2\" }, \"files\" : { \"href\" : \"http://localhost:8080/files/2\" } } } ] }, \"_links\" : { \"self\" : { \"href\" : \"http://localhost:8080/files/searchContent?queryString=Content\" } } } Spring Content found the second document that we added because its content included the keyword \"Content\" that we searched for.","title":"Create an Entity"},{"location":"spring-content-with-fulltext-docs/#summary","text":"Congratulations! You've just written a simple application that uses Spring Content with Elasticsearch to index content so that searches can be performed against that content. This guide demonstrates the Spring Content Elasticsearch Module. Spring Content also supports Solr with the Spring Content Solr Module. To use Solr, simply update the spring-content-elasticsearch-boot-starter dependency for spring-content-solr-boot-starter .","title":"Summary"},{"location":"spring-content-with-renditions-docs/","text":"Getting Started Spring Content with Fulltext What you'll build We'll build on the previous guide Getting Started with Spring Content REST API . What you'll need About 30 minutes A favorite text editor or IDE JDK 1.8 or later Maven 3.0+ How to complete this guide Before we begin let's set up our development environment: Download and unzip the source repository for this guide, or clone it using Git: git clone https://github.com/paulcwarren/spring-content-gettingstarted.git We are going to start where Getting Started with Spring Content REST API leaves off so cd into spring-content-gettingstarted/spring-content-rest/complete When you\u2019re finished, you can check your results against the code in spring-content-gettingstarted/spring-content-with-fulltext/complete . Update dependencies Add the com.github.paulcwarren:spring-content-renditions-boot-starter dependency. pom.xml {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-with-renditions/complete/pom.xml 1-} Update File To be able to return renditions we need to know the mime-type of the existing content. Annotate the mimeType field with the MimeType annotation so that it will be by Spring Content REST. src/main/java/gettingstarted/FileContentStore.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-with-renditions/complete/src/main/java/gettingstarted/File.java 1-} Update FileContentStore So that we can fetch renditions make your FileContentStore extend Renderable . src/main/java/gettingstarted/FileContentStore.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-with-renditions/complete/src/main/java/gettingstarted/FileContentStore.java 1-} Build an executable JAR If you are using Maven, you can run the application using mvn spring-boot:run . Or you can build the JAR file with mvn clean package and run the JAR by typing: java -jar target/gettingstarted-spring-content-with-renditions-0.0.1.jar Test renditions Create an entity: curl -X POST -H 'Content-Type:application/hal+json' -d '{}' http://localhost:8080/files/ Associate content with that entity: curl -X PUT -H 'Content-Type:text/plain' -d 'Hello Spring Content World!' http://localhost:8080/files/1 Fetch the content: curl -H 'Accept:text/plain' http://localhost:8080/files/1 And you should see a response like this: Hello Spring Content World! Fetch the content again but this time specify that we want a jpeg rendition of the content by specify the mime-type image/jpeg as the accept header. As it is an image let's save it to a file: curl -H 'Accept:image/jpeg' http://localhost:8080/files/1 --output /tmp/file-1.jpg Open /tmp/file-1.jpg and you should see a response like this: Summary Congratulations! You've just written a simple application that uses Spring Content and Spring Content Renditions to be able to transform contnet from one format to another. This guide demonstrates the Spring Content Renditions Module. This module supports several renderers out-of-the-box satisfying most use cases. However, you may also add your own renderers using the RenditionProvider extension point. For more details see the Spring Content Renditions reference guide.","title":"Renditions"},{"location":"spring-content-with-renditions-docs/#getting-started-spring-content-with-fulltext","text":"","title":"Getting Started Spring Content with Fulltext"},{"location":"spring-content-with-renditions-docs/#what-youll-build","text":"We'll build on the previous guide Getting Started with Spring Content REST API .","title":"What you'll build"},{"location":"spring-content-with-renditions-docs/#what-youll-need","text":"About 30 minutes A favorite text editor or IDE JDK 1.8 or later Maven 3.0+","title":"What you'll need"},{"location":"spring-content-with-renditions-docs/#how-to-complete-this-guide","text":"Before we begin let's set up our development environment: Download and unzip the source repository for this guide, or clone it using Git: git clone https://github.com/paulcwarren/spring-content-gettingstarted.git We are going to start where Getting Started with Spring Content REST API leaves off so cd into spring-content-gettingstarted/spring-content-rest/complete When you\u2019re finished, you can check your results against the code in spring-content-gettingstarted/spring-content-with-fulltext/complete .","title":"How to complete this guide"},{"location":"spring-content-with-renditions-docs/#update-dependencies","text":"Add the com.github.paulcwarren:spring-content-renditions-boot-starter dependency. pom.xml {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-with-renditions/complete/pom.xml 1-}","title":"Update dependencies"},{"location":"spring-content-with-renditions-docs/#update-file","text":"To be able to return renditions we need to know the mime-type of the existing content. Annotate the mimeType field with the MimeType annotation so that it will be by Spring Content REST. src/main/java/gettingstarted/FileContentStore.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-with-renditions/complete/src/main/java/gettingstarted/File.java 1-}","title":"Update File"},{"location":"spring-content-with-renditions-docs/#update-filecontentstore","text":"So that we can fetch renditions make your FileContentStore extend Renderable . src/main/java/gettingstarted/FileContentStore.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-with-renditions/complete/src/main/java/gettingstarted/FileContentStore.java 1-}","title":"Update FileContentStore"},{"location":"spring-content-with-renditions-docs/#build-an-executable-jar","text":"If you are using Maven, you can run the application using mvn spring-boot:run . Or you can build the JAR file with mvn clean package and run the JAR by typing: java -jar target/gettingstarted-spring-content-with-renditions-0.0.1.jar","title":"Build an executable JAR"},{"location":"spring-content-with-renditions-docs/#test-renditions","text":"Create an entity: curl -X POST -H 'Content-Type:application/hal+json' -d '{}' http://localhost:8080/files/ Associate content with that entity: curl -X PUT -H 'Content-Type:text/plain' -d 'Hello Spring Content World!' http://localhost:8080/files/1 Fetch the content: curl -H 'Accept:text/plain' http://localhost:8080/files/1 And you should see a response like this: Hello Spring Content World! Fetch the content again but this time specify that we want a jpeg rendition of the content by specify the mime-type image/jpeg as the accept header. As it is an image let's save it to a file: curl -H 'Accept:image/jpeg' http://localhost:8080/files/1 --output /tmp/file-1.jpg Open /tmp/file-1.jpg and you should see a response like this:","title":"Test renditions"},{"location":"spring-content-with-renditions-docs/#summary","text":"Congratulations! You've just written a simple application that uses Spring Content and Spring Content Renditions to be able to transform contnet from one format to another. This guide demonstrates the Spring Content Renditions Module. This module supports several renderers out-of-the-box satisfying most use cases. However, you may also add your own renderers using the RenditionProvider extension point. For more details see the Spring Content Renditions reference guide.","title":"Summary"},{"location":"spring-content-with-versions-docs/","text":"Getting Started Spring Content with Versions What you'll build We'll build on the previous guide Getting Started with Spring Content REST API . What you'll need About 30 minutes A favorite text editor or IDE JDK 1.8 or later Maven 3.0+ How to complete this guide Before we begin let's set up our development environment: Download and unzip the source repository for this guide, or clone it using Git: git clone https://github.com/paulcwarren/spring-content-gettingstarted.git We are going to start where Getting Started with Spring Content REST API leaves off so cd into spring-content-gettingstarted/spring-content-rest/complete When you\u2019re finished, you can check your results against the code in spring-content-gettingstarted/spring-content-with-versions/complete . Update dependencies Add the com.github.paulcwarren:spring-versions-boot-starter and org.springframework.boot:spring-boot-starter-security dependencies. pom.xml {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-with-versions/complete/pom.xml 1-} Update File Entity Add the following annotations to our Entity. src/main/java/gettingstarted/File.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-with-versions/complete/src/main/java/gettingstarted/File.java 1-} @LockOwner ; tracks the current lock owner. Optional @AncestorId ; references the entity that came immediately before in the version series @AncestorRootId ; references the entity that came first in the version series @SuccessorId ; references the entity that came after in the version series @VersionNumber ; version designation @VersionLabel ; description of the version Also note the copy constructor. An Entity can be complex. It is impossible for Spring Content to know exactly how to stamp out a new version when it needs to. This is where the copy constructor comes in. The copy constructor tells Spring Content how to create a new version. There is no need to copy the version attributes as they will be managed as part of the version creation process. Other than that, it is up to you. Update FileRepository So that we can perform version operations on an Entity make your FileRepository extend LockingAndVersioningRepository . src/main/java/gettingstarted/FileRepository.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-with-versions/complete/src/main/java/gettingstarted/FileRepository.java 1-} Update Configuratoin Add a Store configuration to tell Spring Data JPA to look in the package org.springframework.versions for the implementation of the LockingAndVersioningRepository . Because of this you will also need to tell Spring Data to find FileRepository in the gettingstarted package. {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-with-versions/complete/src/main/java/gettingstarted/SpringContentApplication.java 29-32} Enable web security and add an anonymous user principal. {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-with-versions/complete/src/main/java/gettingstarted/SpringContentApplication.java 34-79} Build an executable JAR If you are using Maven, you can run the application using mvn spring-boot:run . Or you can build the JAR file with mvn clean package and run the JAR by typing: java -jar target/gettingstarted-spring-content-with-versions-0.0.1.jar Create an Entity and version it Create an entity: curl -X POST -H 'Content-Type:application/hal+json' -d '{}' http://localhost:8080/files/ Associate content: curl -X PUT -H 'Content-Type:text/plain' -d 'Hello Spring Content with Versions World!' http://localhost:8080/files/1 Lock the Entity to prevent others from editing it: curl -X PUT -H 'Content-Type:application/hal+json' http://localhost:8080/files/1/lock Create a new version of the entity: curl -X PUT -H 'Content-Type:application/hal+json' -d '{\"number\":\"1.1\",\"label\":\"some minor changes\"}' http://localhost:8080/files/1/version Unlock the new version of the Entity: curl -X DELETE -H 'Accept:application/hal+json' http://localhost:8080/files/2/lock Fetch the version series: curl -H 'Accept:application/hal+json' http://localhost:8080/files/ Verify you now see two entities that are in a version series with each other. Summary Congratulations! You've written a simple application that uses Spring Content with Versions to create a version series of entities with associated content. Don't forget you can simply change the type of the spring-content bootstarter project on the classpath to switch from file storage to a different storage technology. The REST and Version Modules works seamlessly with all of the storage modules. Spring Content supports the following implementations:- Spring Content Filesystem; stores content as Files on the Filesystem (as used in this tutorial) Spring Content S3; stores content as Objects in Amazon S3 Spring Content JPA; stores content as BLOBs in the database Spring Content MongoDB; stores content as Resources in Mongo's GridFS","title":"Versions"},{"location":"spring-content-with-versions-docs/#getting-started-spring-content-with-versions","text":"","title":"Getting Started Spring Content with Versions"},{"location":"spring-content-with-versions-docs/#what-youll-build","text":"We'll build on the previous guide Getting Started with Spring Content REST API .","title":"What you'll build"},{"location":"spring-content-with-versions-docs/#what-youll-need","text":"About 30 minutes A favorite text editor or IDE JDK 1.8 or later Maven 3.0+","title":"What you'll need"},{"location":"spring-content-with-versions-docs/#how-to-complete-this-guide","text":"Before we begin let's set up our development environment: Download and unzip the source repository for this guide, or clone it using Git: git clone https://github.com/paulcwarren/spring-content-gettingstarted.git We are going to start where Getting Started with Spring Content REST API leaves off so cd into spring-content-gettingstarted/spring-content-rest/complete When you\u2019re finished, you can check your results against the code in spring-content-gettingstarted/spring-content-with-versions/complete .","title":"How to complete this guide"},{"location":"spring-content-with-versions-docs/#update-dependencies","text":"Add the com.github.paulcwarren:spring-versions-boot-starter and org.springframework.boot:spring-boot-starter-security dependencies. pom.xml {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-with-versions/complete/pom.xml 1-}","title":"Update dependencies"},{"location":"spring-content-with-versions-docs/#update-file-entity","text":"Add the following annotations to our Entity. src/main/java/gettingstarted/File.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-with-versions/complete/src/main/java/gettingstarted/File.java 1-} @LockOwner ; tracks the current lock owner. Optional @AncestorId ; references the entity that came immediately before in the version series @AncestorRootId ; references the entity that came first in the version series @SuccessorId ; references the entity that came after in the version series @VersionNumber ; version designation @VersionLabel ; description of the version Also note the copy constructor. An Entity can be complex. It is impossible for Spring Content to know exactly how to stamp out a new version when it needs to. This is where the copy constructor comes in. The copy constructor tells Spring Content how to create a new version. There is no need to copy the version attributes as they will be managed as part of the version creation process. Other than that, it is up to you.","title":"Update File Entity"},{"location":"spring-content-with-versions-docs/#update-filerepository","text":"So that we can perform version operations on an Entity make your FileRepository extend LockingAndVersioningRepository . src/main/java/gettingstarted/FileRepository.java {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-with-versions/complete/src/main/java/gettingstarted/FileRepository.java 1-}","title":"Update FileRepository"},{"location":"spring-content-with-versions-docs/#update-configuratoin","text":"Add a Store configuration to tell Spring Data JPA to look in the package org.springframework.versions for the implementation of the LockingAndVersioningRepository . Because of this you will also need to tell Spring Data to find FileRepository in the gettingstarted package. {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-with-versions/complete/src/main/java/gettingstarted/SpringContentApplication.java 29-32} Enable web security and add an anonymous user principal. {snippet: https://raw.githubusercontent.com/paulcwarren/spring-content-gettingstarted/master/spring-content-with-versions/complete/src/main/java/gettingstarted/SpringContentApplication.java 34-79}","title":"Update Configuratoin"},{"location":"spring-content-with-versions-docs/#build-an-executable-jar","text":"If you are using Maven, you can run the application using mvn spring-boot:run . Or you can build the JAR file with mvn clean package and run the JAR by typing: java -jar target/gettingstarted-spring-content-with-versions-0.0.1.jar","title":"Build an executable JAR"},{"location":"spring-content-with-versions-docs/#create-an-entity-and-version-it","text":"Create an entity: curl -X POST -H 'Content-Type:application/hal+json' -d '{}' http://localhost:8080/files/ Associate content: curl -X PUT -H 'Content-Type:text/plain' -d 'Hello Spring Content with Versions World!' http://localhost:8080/files/1 Lock the Entity to prevent others from editing it: curl -X PUT -H 'Content-Type:application/hal+json' http://localhost:8080/files/1/lock Create a new version of the entity: curl -X PUT -H 'Content-Type:application/hal+json' -d '{\"number\":\"1.1\",\"label\":\"some minor changes\"}' http://localhost:8080/files/1/version Unlock the new version of the Entity: curl -X DELETE -H 'Accept:application/hal+json' http://localhost:8080/files/2/lock Fetch the version series: curl -H 'Accept:application/hal+json' http://localhost:8080/files/ Verify you now see two entities that are in a version series with each other.","title":"Create an Entity and version it"},{"location":"spring-content-with-versions-docs/#summary","text":"Congratulations! You've written a simple application that uses Spring Content with Versions to create a version series of entities with associated content. Don't forget you can simply change the type of the spring-content bootstarter project on the classpath to switch from file storage to a different storage technology. The REST and Version Modules works seamlessly with all of the storage modules. Spring Content supports the following implementations:- Spring Content Filesystem; stores content as Files on the Filesystem (as used in this tutorial) Spring Content S3; stores content as Objects in Amazon S3 Spring Content JPA; stores content as BLOBs in the database Spring Content MongoDB; stores content as Resources in Mongo's GridFS","title":"Summary"}]}